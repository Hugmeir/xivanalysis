{"version":3,"file":"assets/4950.71681f01.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/Procs.tsx"],"sourcesContent":["import {t} from '@lingui/macro'\nimport {Trans, Plural} from '@lingui/react'\nimport {Action} from 'data/ACTIONS'\nimport {Status} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport {Actors} from 'parser/core/modules/Actors'\nimport Suggestions, {TieredSuggestion, SEVERITY, SeverityTiers} from 'parser/core/modules/Suggestions'\nimport {SimpleRow, StatusItem, Timeline} from 'parser/core/modules/Timeline'\nimport React, {ReactNode} from 'react'\nimport {Analyser} from '../Analyser'\nimport {filter, oneOf} from '../filter'\nimport {dependency} from '../Injectable'\nimport {Data} from './Data'\nimport Downtime from './Downtime'\nimport {Invulnerability} from './Invulnerability'\n\nexport interface ProcBuffWindow {\n\tstart: number,\n\tstop?: number\n}\n\nexport interface ProcGroup {\n\tprocStatus: Status,\n\tconsumeActions: Action[],\n\tmayOverwrite?: boolean,\n\tprocsBecomeInstant?: boolean,\n}\n\nexport interface ProcGroupEvents {\n\ttimestamps: number[],\n\tevents: Event[]\n}\n\ntype ProcStatusEventType =\n\t| 'overwrite'\n\t| 'removal'\n\t| 'usage'\n\nconst DEFAULT_SEVERITY_TIERS = {\n\t1: SEVERITY.MINOR,\n\t2: SEVERITY.MEDIUM,\n\t3: SEVERITY.MAJOR,\n}\nexport abstract class Procs extends Analyser {\n\tstatic override handle = 'procs'\n\tstatic override title = t('core.procs.title')`Procs`\n\n\t@dependency private downtime!: Downtime\n\t@dependency protected suggestions!: Suggestions\n\t@dependency private timeline!: Timeline\n\t@dependency protected actors!: Actors\n\t@dependency protected data!: Data\n\t@dependency protected invulnerability!: Invulnerability\n\n\tprotected droppedProcs: number = 0\n\tprotected overwrittenProcs: number = 0\n\tprotected invulnUsages: number = 0\n\n\t/**\n\t * Subclassing analysers must provide a list of tracked procs\n\t * Note that if a given action can consume multiple proc statuses, the statuses should be listed in the order that the game will consume them\n\t * See DNC's Procs subclass for an example\n\t */\n\tprotected abstract trackedProcs: ProcGroup[]\n\n\t/**\n\t * Subclassing analysers may override these suggestion properties with relevant job-specific ones\n\t */\n\tprotected showDroppedProcSuggestion: boolean = false\n\tprotected droppedProcIcon: string = 'https://xivapi.com/i/001000/001989.png' // Hasty Touch ...\n\tprotected droppedProcContent: ReactNode = <Trans id=\"core.procs.suggestions.dropped.content\">Avoid letting your procs fall off without using them. Proc actions are generally stronger than other actions and should not be wasted.</Trans>\n\tprotected droppedProcSeverityTiers: SeverityTiers = DEFAULT_SEVERITY_TIERS\n\n\tprotected showOverwroteProcSuggestion: boolean = false\n\tprotected overwroteProcIcon: string = 'https://xivapi.com/i/001000/001994.png' // Muscle Memory ...\n\tprotected overwroteProcContent: ReactNode = <Trans id=\"core.procs.suggestions.overwritten.content\">Avoid using an action that could generate a proc when you already have that proc active.</Trans>\n\tprotected overwroteProcSeverityTiers: SeverityTiers = DEFAULT_SEVERITY_TIERS\n\n\tprotected showInvulnProcSuggestion: boolean = false\n\tprotected invulnProcIcon: string = this.data.actions.HALLOWED_GROUND.icon // lol\n\tprotected invulnProcContent: ReactNode = <Trans id=\"core.procs.suggestions.invuln.content\">Try not to use your procs while the boss is invulnerable.</Trans>\n\tprotected invulnProcSeverityTiers: SeverityTiers = DEFAULT_SEVERITY_TIERS\n\n\t/**\n\t * Subclassing analysers may override this to toggle off timeline display\n\t */\n\tprotected showProcTimelineRow: boolean = true\n\n\t/**\n\t * Subclassing analysers should not assign these directly. The corresponding override functions should be used instead to ensure that the\n\t * variables needed for the Plurals typically used in suggestion Whys are ready for setting into the object\n\t */\n\tprotected droppedProcWhy!: ReactNode\n\tprotected overwroteProcWhy!: ReactNode\n\tprotected invulnProcWhy!: ReactNode\n\n\tprivate usages = new Map<ProcGroup, ProcGroupEvents>()\n\t/**\n\t * Get an array of usage events for a given proc status\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The array of usage Events\n\t */\n\tprotected getUsagesForStatus(status: number | ProcGroup): Event[] {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return [] }\n\t\treturn this.usages.get(procGroup)?.events || []\n\t}\n\t/**\n\t * Get the number of times a proc was used\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The number of times the proc was used\n\t */\n\tprotected getUsageCountForStatus(status: number | ProcGroup): number {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return 0 }\n\t\treturn this.usages.get(procGroup)?.events.length || 0\n\t}\n\t/**\n\t * Checks to see if the specified event was a proc usage\n\t * @param event The event to check\n\t * @returns True if that event is contained in the usages group, false if not\n\t */\n\tpublic checkEventWasProc(event: Events['action']): boolean {\n\t\treturn this.checkActionWasProc(event.action, event.timestamp)\n\t}\n\t/**\n\t * Checks to see if the specified action consumed a proc at a given timestamp\n\t * @param actionId The action to check\n\t * @param timestamp The timestamp to check\n\t * @returns True if there was a tracked proc usage for the action at the given timestamp, false otherwise\n\t */\n\tprivate checkActionWasProc(actionId: number, timestamp: number): boolean {\n\t\tconst procGroups = this.getTrackedGroupsByAction(actionId)\n\t\tif (procGroups.length === 0) { return false }\n\t\tlet wasProc = false\n\t\tfor (const procGroup of procGroups) {\n\t\t\twasProc = wasProc || this.getUsagesForStatus(procGroup).some(event => event.timestamp === timestamp)\n\t\t}\n\t\treturn wasProc\n\t}\n\n\tprivate overwrites = new Map<ProcGroup, ProcGroupEvents>()\n\t/**\n\t * Get an array of overwrite events for a given proc status\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The array of overwrite Events\n\t */\n\tprotected getOverwritesForStatus(status: number | ProcGroup): Event[] {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return [] }\n\t\treturn this.overwrites.get(procGroup)?.events || []\n\t}\n\t/**\n\t * Get the number of times a proc was overwritten\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The number of times the proc was overwritten\n\t */\n\tprotected getOverwriteCountForStatus(status: number | ProcGroup): number {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return 0 }\n\t\treturn this.overwrites.get(procGroup)?.events.length || 0\n\t}\n\n\tprivate removals = new Map<ProcGroup, ProcGroupEvents>()\n\t/**\n\t * Get an array of removal events for a given proc status\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The array of removal Events\n\t */\n\tprotected getRemovalsForStatus(status: number | ProcGroup): Event[] {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return [] }\n\t\treturn this.removals.get(procGroup)?.events || []\n\t}\n\t/**\n\t * Get the number of times a proc was removed\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The number of times the proc was removed\n\t */\n\tprotected getRemovalCountForStatus(status: number | ProcGroup): number {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return 0 }\n\t\treturn this.removals.get(procGroup)?.events.length || 0\n\t}\n\n\tprivate invulns = new Map<ProcGroup, ProcGroupEvents>()\n\t/**\n\t * Get an array of invulnerable usage events for a given proc status\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The array of invulnerable usage Events\n\t */\n\tprotected getInvulnsForStatus(status: number | ProcGroup): Event[] {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return [] }\n\t\treturn this.invulns.get(procGroup)?.events || []\n\t}\n\t/**\n\t * Get the number of times a proc was used on an invulnerable target\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The number of times the proc was used on an invulnerable target\n\t */\n\tprotected getInvulnCountForStatus(status: number | ProcGroup): number {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return 0 }\n\t\treturn this.invulns.get(procGroup)?.events.length || 0\n\t}\n\n\t/**\n\t * Gets the number of times a proc was allowed to fall off\n\t * @param status The status, as an ID number or ProcGroup object\n\t * @returns The number of times the proc was dropped (removals - usages)\n\t */\n\tprotected getDropCountForStatus(status: number| ProcGroup): number {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return 0 }\n\t\treturn this.getRemovalCountForStatus(status) - this.getUsageCountForStatus(status)\n\t}\n\n\tprivate currentWindows = new Map<ProcGroup, ProcBuffWindow>()\n\tprivate history = new Map<ProcGroup, ProcBuffWindow[]>()\n\t/**\n\t * Gets the array of buff windows for a specified status\n\t * @param status The status to get windows for, as either the ID or a ProcGroup object\n\t * @returns An array of ProcBuffWindows\n\t */\n\tprotected getHistoryForStatus(status: number| ProcGroup): ProcBuffWindow[] {\n\t\tconst procGroup = this.getTrackedGroupByStatus(status)\n\t\tif (procGroup == null) { return [] }\n\t\treturn this.history.get(procGroup) || []\n\t}\n\n\tprivate row!: SimpleRow\n\tprivate rows = new Map()\n\n\tprotected castingSpellId?: number\n\n\toverride initialise() {\n\t\tconst playerFilter = filter<Event>().source(this.parser.actor.id)\n\t\tthis.addEventHook(playerFilter.type('prepare'), this.onPrepare)\n\t\tthis.addEventHook(playerFilter.type('interrupt'), this.onInterrupt)\n\n\t\tconst trackedProcActionsIds: number[] = this.trackedProcs.map(group => group.consumeActions).reduce((acc, cur) => acc.concat(cur)).map(action => action.id)\n\t\tconst trackedActionFilter = playerFilter.action(oneOf(trackedProcActionsIds))\n\t\tthis.addEventHook(trackedActionFilter.type('action'), this.onCast)\n\n\t\tconst trackedProcStatusIds: number[] = this.trackedProcs.map(group => group.procStatus.id)\n\t\tconst trackedStatusFilter = playerFilter.status(oneOf(trackedProcStatusIds))\n\t\tthis.addEventHook(trackedStatusFilter.type('statusApply'), this.onProcGained)\n\t\tthis.addEventHook(trackedStatusFilter.type('statusRemove'), this.onProcRemoved)\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\n\t\tif (this.showProcTimelineRow) {\n\t\t\tthis.row = this.timeline.addRow(new SimpleRow({\n\t\t\t\tlabel: 'Procs',\n\t\t\t\torder: 0,\n\t\t\t}))\n\t\t}\n\n\t\tthis.trackedProcs.forEach(group => {\n\t\t\tthis.usages.set(group, {timestamps: [], events: []})\n\t\t\tthis.overwrites.set(group, {timestamps: [], events: []})\n\t\t\tthis.removals.set(group, {timestamps: [], events: []})\n\t\t\tthis.invulns.set(group, {timestamps: [], events: []})\n\t\t\tthis.history.set(group, [])\n\t\t})\n\t}\n\n\tprivate onPrepare(event: Events['prepare']): void {\n\t\tthis.castingSpellId = event.action\n\t}\n\n\tprivate onInterrupt(_event: Events['interrupt']): void {\n\t\tthis.castingSpellId = undefined\n\t}\n\n\t/**\n\t * Checks to see if the event in question consumes the given proc\n\t * @param procGroup The proc that may be consumed\n\t * @param event The event that may consume the proc\n\t * @returns True if the event consumes the proc, false if it does not\n\t */\n\tprivate checkConsumeProc(procGroup: ProcGroup, event: Events['action']): boolean {\n\t\t// If we don't currently have this proc active, we can't possibly consume it\n\t\tif (!this.currentWindows.has(procGroup)) { return false }\n\t\t// If we have no idea what this action is, it doesn't consume it\n\t\tif (this.data.getAction(event.action) == null) { return false }\n\n\t\t// If we pass the error checks, return the value from jobSpecificCheckConsumeProc\n\t\t// Subclasses can assume the basic error handling is dealt with and focus on only the job-specific logic\n\t\treturn this.jobSpecificCheckConsumeProc(procGroup, event)\n\t}\n\n\t/**\n\t * May be overridden by subclasses. Called by onCast to allow jobs to add specific logic that determines whether a proc was consumed\n\t * @param _procGroup The procGroup to check for consumption\n\t * @param _event The event to check\n\t */\n\tprotected jobSpecificCheckConsumeProc(_procGroup: ProcGroup, _event: Events['action']): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * May be overridden by subclasses. Called by onCast to allow jobs to add specific handlers for a consumed proc\n\t * @param _procGroup The procGroup to add consumption handling for\n\t * @param _event The event triggering a proc consumption\n\t*/\n\tprotected jobSpecificOnConsumeProc(_procGroup: ProcGroup, _event: Events['action']): void { /* */ }\n\n\tprivate onCast(event: Events['action']): void {\n\t\tconst procGroups = this.getTrackedGroupsByAction(event.action)\n\n\t\tfor (const procGroup of procGroups) {\n\t\t\t// If this action consumed a proc, log it\n\t\t\tif (this.checkConsumeProc(procGroup, event)) {\n\t\t\t\tthis.stopAndSave(procGroup, event, 'usage')\n\n\t\t\t\tthis.jobSpecificOnConsumeProc(procGroup, event)\n\t\t\t\tbreak // Get out of the loop, we only consume one proc status at a time\n\t\t\t}\n\t\t}\n\n\t\t// Reset the variable tracking hardcasts since we just finished casting something\n\t\tthis.castingSpellId = undefined\n\t}\n\n\tprivate onProcGained(event: Events['statusApply']): void {\n\t\tconst procGroup = this.getTrackedGroupByStatus(event.status)\n\n\t\tif (procGroup == null) { return }\n\n\t\tif (this.currentWindows.has(procGroup)) {\n\t\t\t// Close this window and open a fresh one so the timeline shows the re-applications correctly\n\t\t\tthis.stopAndSave(procGroup, event, 'overwrite')\n\t\t}\n\t\tthis.currentWindows.set(procGroup, {\n\t\t\tstart: event.timestamp,\n\t\t})\n\t}\n\n\tprivate onProcRemoved(event: Events['statusRemove']): void {\n\t\tconst procGroup = this.getTrackedGroupByStatus(event.status)\n\n\t\tif (procGroup == null) { return }\n\n\t\tthis.stopAndSave(procGroup, event, 'removal')\n\t}\n\n\t/**\n\t * May be overridden by subclasses. Called in onComplete to override the default icon for the dropped procs suggestion,\n\t * if there is job-specific logic for picking the right one\n\t */\n\tprotected overrideDroppedProcsIcon(): void { /* no op */ }\n\n\t/**\n\t * May be overridden by subclasses. Called in onComplete to override the default icon for the overwrote procs suggestion,\n\t * if there is job-specific logic for picking the right one\n\t */\n\tprotected overrideOverwroteProcsIcon(): void { /* no op */ }\n\n\t/**\n\t * May be overridden by subclasses. Called in onComplete to override the default icon for the invuln procs suggestion,\n\t * if there is job-specific logic for picking the right one\n\t */\n\tprotected overrideInvulnProcsIcon(): void { /* no op */ }\n\n\t/**\n\t * May be overridden by subclasses. Called in onComplete to set the 'why' component of the dropped procs suggestion after the value for the plural\n\t * has been calculated\n\t */\n\tprotected overrideDroppedProcsWhy(): void {\n\t\tthis.droppedProcWhy = <Trans id=\"core.procs.suggestions.dropped.why\">You dropped <Plural value={this.droppedProcs} one=\"# proc\" other=\"# procs\" />.</Trans>\n\t}\n\n\t/**\n\t* May be overridden by subclasses. Called in onComplete to set the 'why' component of the overwrote procs suggestion after the value for the plural\n\t* has been calculated\n\t*/\n\tprotected overrideOverwroteProcsWhy(): void {\n\t\tthis.overwroteProcWhy = <Trans id=\"core.procs.suggestions.overwrote.why\">You overwrote <Plural value={this.overwrittenProcs} one=\"# proc\" other=\"# procs\" />.</Trans>\n\t}\n\n\t/**\n\t* May be overridden by subclasses. Called in onComplete to set the 'why' component of the invuln procs suggestion after the value for the plural\n\t* has been calculated\n\t*/\n\tprotected overrideInvulnProcsWhy(): void {\n\t\tthis.invulnProcWhy = <Trans id=\"core.procs.suggestions.invuln.why\">You used <Plural value={this.invulnUsages} one=\"# proc\" other=\"# procs\" /> on an invulnerable target.</Trans>\n\t}\n\n\t/**\n\t * May be overridden by subclasses. Called in onComplete to add any job-specific suggestions above and beyond the core suggestions\n\t */\n\tprotected addJobSpecificSuggestions(): void { /* no op */ }\n\n\tprivate onComplete(): void {\n\t\tthis.trackedProcs.forEach(procGroup => {\n\t\t\tconst status = procGroup.procStatus\n\t\t\tif (status == null) { return }\n\n\t\t\tconst fightStart = this.parser.pull.timestamp\n\t\t\t// Finalise the buff if it was still active, shouldn't be counted as dropped or overwritten\n\t\t\tthis.stopAndSave(procGroup)\n\n\t\t\t// Add buff windows to the timeline\n\t\t\tif (this.showProcTimelineRow) {\n\t\t\t\tconst row = this.getRowForStatus(status)\n\t\t\t\tthis.history.get(procGroup)?.forEach(window => {\n\t\t\t\t\tif (window.stop == null) { return }\n\t\t\t\t\trow.addItem(new StatusItem({\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\tstart: window.start - fightStart,\n\t\t\t\t\t\tend: window.stop - fightStart,\n\t\t\t\t\t}))\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\t// Dropped Procs\n\t\tif (this.showDroppedProcSuggestion) {\n\t\t\tthis.trackedProcs.forEach(procGroup => this.droppedProcs += this.getDropCountForStatus(procGroup.procStatus.id))\n\t\t\tthis.overrideDroppedProcsIcon()\n\t\t\tthis.overrideDroppedProcsWhy()\n\t\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\t\ticon: this.droppedProcIcon,\n\t\t\t\tcontent: this.droppedProcContent,\n\t\t\t\twhy: this.droppedProcWhy,\n\t\t\t\ttiers: this.droppedProcSeverityTiers,\n\t\t\t\tvalue: this.droppedProcs,\n\t\t\t}))\n\t\t}\n\n\t\t// Overwritten Procs\n\t\tif (this.showOverwroteProcSuggestion) {\n\t\t\tthis.trackedProcs.forEach(procGroup => this.overwrittenProcs += this.getOverwriteCountForStatus(procGroup.procStatus.id))\n\t\t\tthis.overrideOverwroteProcsIcon()\n\t\t\tthis.overrideOverwroteProcsWhy()\n\t\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\t\ticon: this.overwroteProcIcon,\n\t\t\t\tcontent: this.overwroteProcContent,\n\t\t\t\twhy: this.overwroteProcWhy,\n\t\t\t\ttiers: this.overwroteProcSeverityTiers,\n\t\t\t\tvalue: this.overwrittenProcs,\n\t\t\t}))\n\t\t}\n\n\t\t// Procs used on invulnerable enemies\n\t\tif (this.showInvulnProcSuggestion) {\n\t\t\tthis.trackedProcs.forEach(procGroup => this.invulnUsages += this.getInvulnCountForStatus(procGroup.procStatus.id))\n\t\t\tthis.overrideInvulnProcsIcon()\n\t\t\tthis.overrideInvulnProcsWhy()\n\t\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\t\ticon: this.invulnProcIcon,\n\t\t\t\tcontent: this.invulnProcContent,\n\t\t\t\twhy: this.invulnProcWhy,\n\t\t\t\ttiers: this.invulnProcSeverityTiers,\n\t\t\t\tvalue: this.invulnUsages,\n\t\t\t}))\n\t\t}\n\n\t\tthis.addJobSpecificSuggestions()\n\t}\n\n\tprivate stopAndSave(procGroup: ProcGroup, event?: Event, type?: ProcStatusEventType): void {\n\n\t\t// Only count usages if the event happens during uptime, you don't get credit for using an AoE-around-self Proc during downtime\n\t\tif (event && type === 'usage' && !this.downtime.isDowntime(event.timestamp)) {\n\t\t\tthis.tryAddEventToUsages(procGroup, event)\n\n\t\t\t// If the target of the cast was invulnerable, keep track of that too\n\t\t\tif (this.invulnerability.isActive({\n\t\t\t\ttimestamp: event.timestamp,\n\t\t\t\tactorFilter: actor => actor.id === (event as Events['action']).target,\n\t\t\t\ttypes: ['invulnerable'],\n\t\t\t})) {\n\t\t\t\tthis.tryAddEventToInvulns(procGroup, event)\n\t\t\t}\n\t\t}\n\n\t\t// Count removals that occur during uptime, and the player is still alive. Don't need to double-penalize deaths or not having GCD space to use all your procs before a downtime\n\t\tif (event && type === 'removal' && !(this.downtime.isDowntime(event.timestamp) || this.actors.current.hp.current === 0)) {\n\t\t\tthis.tryAddEventToRemovals(procGroup, event)\n\t\t}\n\n\t\t// If this was an overwrite event, and overwrites are disallowed for this proc, save a record of that\n\t\tif (event && type === 'overwrite' && !procGroup.mayOverwrite) {\n\t\t\tthis.tryAddEventToOverwrites(procGroup, event)\n\t\t}\n\n\t\tif (!this.currentWindows.has(procGroup)) { return }\n\n\t\tconst currentWindow = this.currentWindows.get(procGroup)\n\t\tif (currentWindow == null) { return }\n\n\t\tcurrentWindow.stop = event?.timestamp ?? this.parser.pull.timestamp + this.parser.pull.duration\n\t\tthis.history.get(procGroup)?.push(currentWindow)\n\t\tthis.currentWindows.delete(procGroup)\n\t}\n\n\t/**\n\t * Add the event to the usage map for the group, if it's not already present in the group\n\t*/\n\tprivate tryAddEventToUsages(procGroup: ProcGroup, event: Event) {\n\t\tthis.tryAddEventToMap(this.usages.get(procGroup), event)\n\t}\n\t/**\n\t * Add the event to the removal map for the group, if it's not already present in the group\n\t * This method is protected so subclassing analysers can hook into it\n\t * Currently only used by BLM to deal with the interaction between T3P and Sharpcast\n\t*/\n\tprotected tryAddEventToRemovals(procGroup: ProcGroup, event: Event) {\n\t\tthis.tryAddEventToMap(this.removals.get(procGroup), event)\n\t}\n\t/**\n\t * Add the event to the invuln map for the group, if it's not already present in the group\n\t*/\n\tprivate tryAddEventToInvulns(procGroup: ProcGroup, event: Event) {\n\t\tthis.tryAddEventToMap(this.invulns.get(procGroup), event)\n\t}\n\t/**\n\t * Add the event to the overwrite map for the group, if it's not already present in the group\n\t*/\n\tprivate tryAddEventToOverwrites(procGroup: ProcGroup, event: Event) {\n\t\tthis.tryAddEventToMap(this.overwrites.get(procGroup), event)\n\t}\n\n\t/** Checks to see if the specified event timestamp already exists in that map, and if not, adds the event to the collection */\n\tprivate tryAddEventToMap(groupEvents: ProcGroupEvents | undefined, event: Event) {\n\t\tif (groupEvents == null) { return }\n\t\tif (groupEvents.timestamps.includes(event.timestamp)) { return }\n\t\tgroupEvents.timestamps.push(event.timestamp)\n\t\tgroupEvents.events.push(event)\n\t}\n\n\t/** Gets the row for a given status, creating it if necessary. Public so Sharpcast can access it */\n\tpublic getRowForStatus(status: Status): SimpleRow {\n\t\tlet row = this.rows.get(status.id)\n\t\tif (row == null) {\n\t\t\trow = this.row.addRow(new SimpleRow({label: status.name}))\n\t\t\tthis.rows.set(status.id, row)\n\t\t}\n\t\treturn row\n\t}\n\n\tprotected getTrackedGroupByStatus(status: number | ProcGroup): ProcGroup | undefined {\n\t\treturn typeof status === 'number' ? this.trackedProcs.find(group => group.procStatus.id === status) : status\n\t}\n\n\tprotected getTrackedGroupsByAction(actionId: number): ProcGroup[] {\n\t\treturn this.trackedProcs.filter(group => group.consumeActions.find(action => action.id === actionId) != null)\n\t}\n}\n"],"names":["DEFAULT_SEVERITY_TIERS","SEVERITY","Procs","Downtime","Suggestions","Timeline","Actors","Data","Invulnerability","droppedProcs","overwrittenProcs","invulnUsages","trackedProcs","showDroppedProcSuggestion","droppedProcIcon","droppedProcContent","Trans","id","droppedProcSeverityTiers","showOverwroteProcSuggestion","overwroteProcIcon","overwroteProcContent","overwroteProcSeverityTiers","showInvulnProcSuggestion","invulnProcIcon","data","actions","HALLOWED_GROUND","icon","invulnProcContent","invulnProcSeverityTiers","showProcTimelineRow","droppedProcWhy","overwroteProcWhy","invulnProcWhy","usages","overwrites","removals","invulns","currentWindows","history","row","rows","castingSpellId","status","procGroup","this","getTrackedGroupByStatus","get","events","length","event","checkActionWasProc","action","timestamp","actionId","procGroups","getTrackedGroupsByAction","wasProc","getUsagesForStatus","some","getRemovalCountForStatus","getUsageCountForStatus","playerFilter","filter","source","parser","actor","addEventHook","type","onPrepare","onInterrupt","trackedProcActionsIds","group","consumeActions","acc","cur","trackedActionFilter","oneOf","onCast","trackedProcStatusIds","procStatus","trackedStatusFilter","onProcGained","onProcRemoved","onComplete","timeline","addRow","SimpleRow","label","order","forEach","set","timestamps","_event","undefined","has","getAction","jobSpecificCheckConsumeProc","_procGroup","checkConsumeProc","stopAndSave","jobSpecificOnConsumeProc","start","fightStart","pull","getRowForStatus","window","stop","addItem","StatusItem","end","getDropCountForStatus","overrideDroppedProcsIcon","overrideDroppedProcsWhy","suggestions","add","TieredSuggestion","content","why","tiers","value","getOverwriteCountForStatus","overrideOverwroteProcsIcon","overrideOverwroteProcsWhy","getInvulnCountForStatus","overrideInvulnProcsIcon","overrideInvulnProcsWhy","addJobSpecificSuggestions","downtime","isDowntime","tryAddEventToUsages","invulnerability","isActive","actorFilter","target","types","tryAddEventToInvulns","actors","current","hp","tryAddEventToRemovals","mayOverwrite","tryAddEventToOverwrites","currentWindow","duration","push","delete","tryAddEventToMap","groupEvents","name","Analyser","handle","title","dependency"],"sourceRoot":""}