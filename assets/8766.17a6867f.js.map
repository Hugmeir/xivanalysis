{"version":3,"file":"assets/8766.17a6867f.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/Gauge/AbstractGauge.ts","webpack://@xivanalysis/client/./src/components/ui/TimeLineChart.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Gauge/Gauge.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Gauge/TimerGauge.ts","webpack://@xivanalysis/client/./src/parser/core/modules/Gauge/CounterGauge.ts"],"sourcesContent":["import {ChartDataSets} from 'chart.js'\nimport Color from 'color'\nimport Parser from 'parser/core/Parser'\nimport {ResourceGraphs} from '../ResourceGraphs'\nimport {ResourceGraphOptions} from '../ResourceGraphs/ResourceGraphs'\n\nexport interface AbstractGaugeOptions {\n\t/** Reference to the parser. Required if not adding the gauge to the core gauge module. */\n\tparser?: Parser\n\tresourceGraphs?: ResourceGraphs\n}\n\nexport interface GaugeGraphOptions extends ResourceGraphOptions {\n\t/** The handle of the timeline group to display this gauge data in. If not passed, will use the default \"Gauges\" group */\n\thandle?: string\n\t/** The color to draw the data set in */\n\tcolor: string | Color\n}\n\nexport abstract class AbstractGauge {\n\tprivate _parser?: Parser\n\tprivate _resourceGraphs?: ResourceGraphs\n\n\t/** The main parser instance. */\n\tprotected get parser() {\n\t\tif (!this._parser) {\n\t\t\tthrow new Error('No parser found. Ensure this gauge is being passed to the core gauge module, or initialised with a reference to the parser.')\n\t\t}\n\n\t\treturn this._parser\n\t}\n\n\tprotected get resourceGraphs() {\n\t\tif (!this._resourceGraphs) {\n\t\t\tthrow new Error('No resource graphs found. Ensure this gauge is being passed to the core gauge module, or initialised with a reference to the resource graphs.')\n\t\t}\n\t\treturn this._resourceGraphs\n\t}\n\n\tconstructor(opts: AbstractGaugeOptions) {\n\t\tthis._parser = opts.parser\n\t}\n\n\t/** Set the function used to retrieve the current timestamp. */\n\tsetParser(parser: Parser) {\n\t\tthis._parser = parser\n\t}\n\n\tsetResourceGraphs(resourceGraphs: ResourceGraphs) {\n\t\tthis._resourceGraphs = resourceGraphs\n\t}\n\n\t/** Reset any values stored within the gauge to their initial state. */\n\tabstract reset(): void\n\n\tabstract raise(): void\n\n\tabstract init(): void\n\n\tgenerateResourceGraph(): void { return }\n\n\tgenerateDataset(): ChartDataSets | undefined { return }\n}\n","import type {ChartData as PureChartData, ChartOptions} from 'chart.js'\nimport _ from 'lodash'\nimport * as PropTypes from 'prop-types'\nimport React, {PureComponent} from 'react'\nimport {ChartData, Line} from 'react-chartjs-2'\n\nconst DEFAULT_OPTIONS: ChartOptions = {\n\taspectRatio: 3,\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'time',\n\t\t\ttime: {\n\t\t\t\tdisplayFormats: {\n\t\t\t\t\tminute: 'm:ss',\n\t\t\t\t\tsecond: 'm:ss',\n\t\t\t\t\tmillisecond: 'm:ss.SS',\n\t\t\t\t},\n\t\t\t\t// This tooltip format displays similar to a \"relative\" timestamp,\n\t\t\t\t// since react assumes UNIX epoch timestamps for the data.\n\t\t\t\ttooltipFormat: 'mm:ss.SSS',\n\t\t\t},\n\t\t}],\n\t},\n}\n\ninterface TimeLineChartProps {\n\tdata: ChartData<PureChartData>\n\toptions?: ChartOptions\n}\n\nexport default class TimeLineChart extends PureComponent<TimeLineChartProps> {\n\tstatic propTypes = {\n\t\tdata: PropTypes.object.isRequired,\n\t\toptions: PropTypes.object,\n\t}\n\n\toverride render() {\n\t\tconst options = _.merge({}, DEFAULT_OPTIONS, this.props.options || {})\n\t\treturn <Line\n\t\t\tdata={this.props.data}\n\t\t\toptions={options}\n\t\t\t// Using this trash 'cus aspectRatio doesn't work with the react wrapper\n\t\t\twidth={options.aspectRatio}\n\t\t\theight={1}\n\t\t/>\n\t}\n}\n","import {t} from '@lingui/macro'\nimport TimeLineChart from 'components/ui/TimeLineChart'\nimport {StatusKey} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport React from 'react'\nimport {isDefined} from 'utilities'\nimport {Data} from '../Data'\nimport {ResourceGraphs} from '../ResourceGraphs'\nimport {AbstractGauge} from './AbstractGauge'\nimport {TimerGauge} from './TimerGauge'\n\nconst PAUSES_TIMER_GAUGE_STATUSES: StatusKey[] = [\n\t'TEMPORAL_DISPLACEMENT_INTERMISSION',\n\t'TEMPORAL_DISPLACEMENT_ENRAGE',\n]\n\nexport class Gauge extends Analyser {\n\tstatic override handle = 'gauge'\n\tstatic override title = t('core.gauge.title')`Gauge`\n\n\t@dependency protected resourceGraphs!: ResourceGraphs\n\t@dependency protected data!: Data\n\n\tprivate gauges: AbstractGauge[] = []\n\n\toverride initialise() {\n\t\tthis.addEventHook({\n\t\t\ttype: 'death',\n\t\t\tactor: this.parser.actor.id,\n\t\t}, this.onDeath)\n\t\tthis.addEventHook({\n\t\t\ttype: 'raise',\n\t\t\tactor: this.parser.actor.id,\n\t\t}, this.onRaise)\n\n\t\t/**\n\t\t * Rigging up a core hook for statuses that cause timers to pause, since the TimerGauges can't do it internally.\n\t\t * Currently this is just TEA's Temporal Displacement, but if we ever encounter another\n\t\t * mechanic like that again in a future fight, we'll have the capability to handle it.\n\t\t */\n\t\tconst pauseTimerFilter = filter<Event>().target(this.parser.actor.id).status(this.data.matchStatusId(PAUSES_TIMER_GAUGE_STATUSES))\n\t\tthis.addEventHook(pauseTimerFilter.type('statusApply'), this.onPauseTimers)\n\t\tthis.addEventHook(pauseTimerFilter.type('statusRemove'), this.onResumeTimers)\n\n\t\tthis.addEventHook('complete', () => this.gauges.forEach(gauge => gauge.generateResourceGraph()))\n\t}\n\n\t/** Add & initialise a gauge implementation to be tracked as part of the core gauge handling. */\n\tadd<T extends AbstractGauge>(gauge: T) {\n\t\tgauge.setParser(this.parser)\n\n\t\t// TODO: Work out how to remove this. Probably also the parser, too.\n\t\tif (gauge instanceof TimerGauge) {\n\t\t\tgauge.setAddTimestampHook(this.addTimestampHook.bind(this))\n\t\t\tgauge.setRemoveTimestampHook(this.removeTimestampHook.bind(this))\n\t\t}\n\n\t\tgauge.setResourceGraphs(this.resourceGraphs)\n\t\tgauge.init()\n\n\t\tthis.gauges.push(gauge)\n\t\treturn gauge\n\t}\n\n\tprotected onDeath(_event: Events['death']) {\n\t\tthis.gauges.forEach(gauge => gauge.reset())\n\t}\n\n\tprotected onRaise() {\n\t\tthis.gauges.forEach(gauge => gauge.raise())\n\t}\n\n\tprivate onPauseTimers() {\n\t\tthis.gauges.forEach(gauge => {\n\t\t\tif (gauge instanceof TimerGauge) {\n\t\t\t\tif (!gauge.paused) {\n\t\t\t\t\tgauge.pause()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate onResumeTimers() {\n\t\tthis.gauges.forEach(gauge => {\n\t\t\tif (gauge instanceof TimerGauge) {\n\t\t\t\tgauge.resume()\n\t\t\t}\n\t\t})\n\t}\n\n\toverride output() {\n\t\t// Generate a dataset from each registered gauge\n\t\tconst datasets = this.gauges\n\t\t\t.map(gauge => gauge.generateDataset())\n\t\t\t.filter(isDefined)\n\n\t\tif (datasets.length < 1) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst data = {datasets}\n\t\treturn <TimeLineChart data={data}/>\n\t}\n}\n","import {Analyser} from 'parser/core/Analyser'\nimport {TimestampHookArguments, TimestampHookCallback} from 'parser/core/Dispatcher'\nimport {GAUGE_HANDLE} from '../ResourceGraphs/ResourceGraphs'\nimport {AbstractGauge, AbstractGaugeOptions, GaugeGraphOptions} from './AbstractGauge'\n\nfunction expectExist<T>(value?: T) {\n\tif (!value) {\n\t\tthrow new Error('Missing something required. Check the stack trace.')\n\t}\n\n\treturn value\n}\n\ninterface State {\n\ttimestamp: number\n\tremaining: number\n\tpaused: boolean\n}\n\ninterface Window {\n\tstart: number\n\tend: number\n}\n\nexport interface TimerGaugeOptions extends AbstractGaugeOptions {\n\t/** Maxiumum duration of the gauge, in milliseconds. */\n\tmaximum: number\n\n\t/** Callback executed when the timer expires. */\n\tonExpiration?: TimestampHookCallback\n\n\t/** Graph options. Omit to disable graphing for this gauge. */\n\tgraph?: GaugeGraphOptions,\n}\n\nexport class TimerGauge extends AbstractGauge {\n\t// Just in case I ever have to change it lmao\n\tprivate readonly minimum = 0\n\tprivate readonly maximum: number\n\tprivate readonly expirationCallback?: TimestampHookCallback\n\tprivate readonly graphOptions?: GaugeGraphOptions\n\n\tprivate hook?: ReturnType<Analyser['addTimestampHook']>\n\tprivate history: State[] = []\n\n\t// TODO: Work out how to remove this reliance on having it passed down\n\tprivate _addTimestampHook?: Analyser['addTimestampHook']\n\tprivate get addTimestampHook() { return expectExist(this._addTimestampHook) }\n\n\tprivate _removeTimestampHook?: Analyser['removeTimestampHook']\n\tprivate get removeTimestampHook() { return expectExist(this._removeTimestampHook) }\n\n\t/** The most recent state  */\n\tprivate get lastKnownState() {\n\t\tconst {length} = this.history\n\t\tif (length === 0) {\n\t\t\treturn\n\t\t}\n\t\treturn this.history[length - 1]\n\t}\n\n\t/** Time currently remaining on the timer. */\n\tget remaining() {\n\t\t// If there's no known state, we have to assume there's no time left\n\t\tif (!this.lastKnownState) {\n\t\t\treturn this.minimum\n\t\t}\n\n\t\t// If we're paused, the time remaining always === specified state remaining\n\t\tif (this.lastKnownState.paused) {\n\t\t\treturn this.lastKnownState.remaining\n\t\t}\n\n\t\tconst delta = this.parser.currentEpochTimestamp - this.lastKnownState.timestamp\n\t\treturn Math.max(this.minimum, this.lastKnownState.remaining - delta)\n\t}\n\n\t/** Whether the gauge has expired. */\n\tget expired() {\n\t\treturn this.remaining <= this.minimum\n\t}\n\n\t/** Whether the gauge is currently paused. */\n\tget paused() {\n\t\t// If there's no state, we're neither paused nor running - but safer to assume running.\n\t\tif (!this.lastKnownState) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn this.lastKnownState.paused\n\t}\n\n\t/** Whether the gauge is currently running */\n\tget active(): boolean {\n\t\treturn !(this.expired || this.paused)\n\t}\n\n\tconstructor(opts: TimerGaugeOptions) {\n\t\tsuper(opts)\n\n\t\tthis.maximum = opts.maximum\n\t\tthis.expirationCallback = opts.onExpiration\n\t\tthis.graphOptions = opts.graph\n\t}\n\n\t/** @inheritdoc */\n\treset() {\n\t\tthis.set(this.minimum)\n\t}\n\n\t/**\n\t * Start the timer from its maximum value\n\t */\n\tstart() {\n\t\tthis.set(this.maximum)\n\t}\n\n\t/**\n\t * Refresh the gauge to its maximum value.\n\t * If the gauge has expired, this will have no effect.\n\t */\n\trefresh(onlyIfRunning: boolean = true) {\n\t\tif (this.expired && onlyIfRunning) {\n\t\t\treturn\n\t\t}\n\t\tthis.start()\n\t}\n\n\t/**\n\t * Add time to the gauge. Time over the maxium will be lost.\n\t * If the gauge has expired, this will have no effect.\n\t */\n\textend(duration: number, onlyIfRunning: boolean = true) {\n\t\tif (this.expired && onlyIfRunning) {\n\t\t\treturn\n\t\t}\n\t\tthis.set(this.remaining + duration)\n\t}\n\n\t/** Pause the timer at its current state. */\n\tpause() {\n\t\tthis.set(this.remaining, true)\n\t}\n\n\t/** Resume the timer from its paused state. */\n\tresume() {\n\t\tthis.set(this.remaining, false)\n\t}\n\n\t/** Set the time remaining on the timer to the given duration. Value will be bounded by provided maximum. */\n\tset(duration: number, paused: boolean = false) {\n\t\tconst timestamp = this.parser.currentEpochTimestamp\n\n\t\t// Push the timer state prior to the event into the history\n\t\tthis.history.push({\n\t\t\ttimestamp,\n\t\t\tremaining: this.remaining,\n\t\t\tpaused: this.paused,\n\t\t})\n\n\t\tconst remaining = Math.max(this.minimum, Math.min(duration, this.maximum))\n\n\t\t// Push a new state onto the history\n\t\tthis.history.push({\n\t\t\ttimestamp,\n\t\t\tremaining,\n\t\t\tpaused,\n\t\t})\n\n\t\t// Remove any existing hook\n\t\tif (this.hook) {\n\t\t\tthis.removeTimestampHook(this.hook)\n\t\t}\n\n\t\t// If we've not yet expired, and we're not paused, set up a hook to wait for that\n\t\tif (!paused && remaining > 0) {\n\t\t\tthis.hook = this.addTimestampHook(timestamp + remaining, this.onExpiration)\n\t\t}\n\t}\n\n\traise() { /** noop */ }\n\n\tinit() {\n\t\tif (this.history.length === 0) {\n\t\t\tthis.reset()\n\t\t}\n\t}\n\n\tprivate onExpiration = (args: TimestampHookArguments) => {\n\t\tif (this.expirationCallback) {\n\t\t\tthis.expirationCallback(args)\n\t\t}\n\t\tthis.history.push({\n\t\t\ttimestamp: this.parser.currentEpochTimestamp,\n\t\t\tremaining: this.remaining,\n\t\t\tpaused: false,\n\t\t})\n\t}\n\n\t/** @inheritdoc */\n\toverride generateResourceGraph() {\n\t\t// Skip charting if they've not enabled it\n\t\tif (!this.graphOptions) {\n\t\t\treturn\n\t\t}\n\n\t\t// Insert a data point at the end of the timeline\n\t\tthis.pause()\n\n\t\tconst {handle, label, color} = this.graphOptions\n\t\tconst graphData = {\n\t\t\tlabel,\n\t\t\tcolour: color,\n\t\t\tdata: this.history.map(entry => {\n\t\t\t\treturn {time: entry.timestamp, current: entry.remaining / 1000, maximum: this.maximum / 1000}\n\t\t\t}),\n\t\t\tlinear: true,\n\t\t}\n\t\tif (handle != null) {\n\t\t\tthis.resourceGraphs.addDataGroup({...this.graphOptions, handle})\n\t\t\tthis.resourceGraphs.addData(handle, graphData)\n\t\t} else {\n\t\t\tthis.resourceGraphs.addGauge(graphData, {...this.graphOptions, handle: GAUGE_HANDLE})\n\t\t}\n\t}\n\n\t// Junk I wish I didn't need\n\tsetAddTimestampHook(value: Analyser['addTimestampHook']) {\n\t\tthis._addTimestampHook = value\n\t}\n\n\tsetRemoveTimestampHook(value: Analyser['removeTimestampHook']) {\n\t\tthis._removeTimestampHook = value\n\t}\n\n\tprivate internalExpirationTime(start: number = this.parser.pull.timestamp, end: number = this.parser.currentEpochTimestamp, downtimeWindows: Window[] = [], reapplyAfterDowntime: number = 0) {\n\t\tlet currentStart: number | undefined = undefined\n\t\tconst expirationWindows: Window[] = []\n\n\t\tthis.history.forEach(entry => {\n\t\t\tif (entry.remaining <= this.minimum && currentStart == null) {\n\t\t\t\tcurrentStart = entry.timestamp\n\t\t\t}\n\t\t\tif (entry.remaining > this.minimum && currentStart != null) {\n\t\t\t\t// Don't clutter the windows if the expiration of the timer may also restart it (Polyglot, Lilies, etc.)\n\t\t\t\tif (entry.timestamp > currentStart) {\n\t\t\t\t\texpirationWindows.push({start: currentStart, end: entry.timestamp})\n\t\t\t\t}\n\t\t\t\tcurrentStart = undefined\n\t\t\t}\n\t\t})\n\n\t\tif (expirationWindows.length === 0) { return [] }\n\n\t\tconst expirations: Window[] = []\n\t\texpirationWindows.forEach(expiration => {\n\t\t\t// If the expiration had some duration within the time range we're asking about, we'll add it\n\t\t\tif ((expiration.end > start || expiration.start < end)) {\n\t\t\t\t/**\n\t\t\t\t * If we were given any downtime windows, check if this expiration started within one, and change the effective start of the expiration\n\t\t\t\t * to the end of the downtime window, plus any additional leniency if specified\n\t\t\t\t */\n\t\t\t\tif (downtimeWindows.length > 0) {\n\t\t\t\t\tdowntimeWindows.filter(uta => expiration.start >= uta.start && expiration.start <= uta.end)\n\t\t\t\t\t\t.forEach(uta => expiration.start = Math.min(expiration.end, uta.end + reapplyAfterDowntime))\n\t\t\t\t}\n\t\t\t\t// If the window still has any effective duration, we'll return it\n\t\t\t\tif (expiration.start < expiration.end) {\n\t\t\t\t\texpirations.push(expiration)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn expirations\n\t}\n\n\t/**\n\t * Gets whether the timer was expired at a particular time\n\t * @param when The timestamp in question\n\t * @returns True if the timer was expired at this timestamp, false if it was active or paused\n\t */\n\tpublic isExpired(when: number = this.parser.currentEpochTimestamp) {\n\t\treturn this.internalExpirationTime(when, when).length > 0\n\t}\n\n\t/**\n\t * Gets the total amount of time that the timer was expired during a given time range.\n\t * @param start The start of the time range. To forgive time at the start of the fight, set this to this.parser.pull.timestamp + forgivenness amount\n\t * @param end The end of the time range.\n\t * @param downtimeWindows Pass to forgive any expirations that began within one of these windows of time. The start of any affected expiration will be reset to the end of the affecting window\n\t *     When using a timer that should only forgive expirations when you are completely unable to act, use the windows from UnableToAct.getWindows()\n\t *     To also forgive expirations due to death or due to no enemy being targetable, use the windows from Downtime.getWindows()\n\t * @param reapplyAfterDowntime Pass to grant additional leniency when an expiration occurred during a downtime window. This is added to the end of the window when recalculating the expiration start time\n\t * @returns The total effective time that the timer was expired for\n\t */\n\tpublic getExpirationTime(start: number = this.parser.pull.timestamp, end: number = this.parser.currentEpochTimestamp, downtimeWindows: Window[] = [], reapplyAfterDowntime: number = 0) {\n\t\treturn this.internalExpirationTime(start, end, downtimeWindows, reapplyAfterDowntime).reduce(\n\t\t\t(totalExpiration, currentWindow) => totalExpiration + Math.min(currentWindow.end, end) - Math.max(currentWindow.start, start),\n\t\t\t0,\n\t\t)\n\t}\n\t/**\n\t * Gets the array of windows that the timer was expired for during a given time range.\n\t * @param start The start of the time range. To forgive time at the start of the fight, set this to this.parser.pull.timestamp + forgivenness amount\n\t * @param end The end of the time range.\n\t * @param downtimeWindows Pass to forgive any expirations that began within one of these windows of time. The start of any affected expiration will be reset to the end of the affecting window\n\t *     When using a timer that should only forgive expirations when you are completely unable to act, use the windows from UnableToAct.getWindows()\n\t *     To also forgive expirations due to death or due to no enemy being targetable, use the windows from Downtime.getWindows()\n\t * @param reapplyAfterDowntime Pass to grant additional leniency when an expiration occurred during a downtime window. This is added to the end of the window when recalculating the expiration start time\n\t * @returns The array of expiration windows\n\t */\n\tpublic getExpirationWindows(start: number = this.parser.pull.timestamp, end: number = this.parser.currentEpochTimestamp, downtimeWindows: Window[] = [], reapplyAfterDowntime: number = 0) {\n\t\treturn this.internalExpirationTime(start, end, downtimeWindows, reapplyAfterDowntime).reduce<Window[]>(\n\t\t\t(windows, window) => {\n\t\t\t\twindows.push({\n\t\t\t\t\tstart: Math.max(window.start, start),\n\t\t\t\t\tend: Math.min(window.end, end),\n\t\t\t\t})\n\t\t\t\treturn windows\n\t\t\t},\n\t\t\t[],\n\t\t)\n\t}\n}\n","import {ChartDataSets} from 'chart.js'\nimport Color from 'color'\nimport _ from 'lodash'\nimport {GAUGE_HANDLE} from '../ResourceGraphs/ResourceGraphs'\nimport {AbstractGauge, AbstractGaugeOptions, GaugeGraphOptions} from './AbstractGauge'\n\ntype GaugeEventReason =\n\t| 'init'\n\t| 'generate'\n\t| 'spend'\n\t| 'reset'\n\t| 'changeBounds'\n\ninterface CounterHistory {\n\ttimestamp: number\n\tvalue: number\n\tminimum: number\n\tmaximum: number\n\tdelta: number\n\treason: GaugeEventReason\n}\n\nexport interface CounterGaugeOptions extends AbstractGaugeOptions {\n\t/** Initial value of the gauge. Defaults to the minimum value of the gauge. */\n\tinitialValue?: number,\n\t/** Minimum value of the gauge. Defaults to 0. */\n\tminimum?: number,\n\t/** Maximum value of the gauge. Defaults to 100. Value over the maximum will be considered over cap, and tracked if enabled. */\n\tmaximum?: number,\n\t/** Chart options. Omit to disable charting for this gauge. Superseded by graph if both are provided */\n\tchart?: CounterChartOptions,\n\t/** Graph options. Omit to disable graphing in the timeline for this gauge. */\n\tgraph?: GaugeGraphOptions\n\t/**\n\t * Should this gauge correct its history in the event of underflow? Must pass true to enable\n\t * Important note:\n\t *   This WILL mutate the history array, but will not re-run any additional logic done partway through the analysis.\n\t *   If you are driving suggestions or other logic off gauge values at specific points in time, that should be run during\n\t *   an onComplete hook, or within the calling class's output function\n\t */\n\tcorrectHistory?: boolean\n\t/**\n\t * Are gauge generation events deterministic (always the same amount when they occur)? Defaults to true if not specified\n\t * Used by the history correction algorithm to decide how far back to look when underflow is detected\n\t * Examples of deterministic gauges: NIN's Ninki, RDM's mana\n\t * Examples of non-deterministic gauges: DNC's Feathers and Esprit, SAM's Kenki\n\t */\n\tdeterministic?: boolean\n}\n\nexport interface CounterChartOptions {\n\t/** Label to display on the data set. */\n\tlabel: string\n\t/** Color to draw the data set in. Defaults to grey. */\n\tcolor?: string | Color\n}\n\nexport class CounterGauge extends AbstractGauge {\n\tprivate initialValue: number\n\tprivate _value: number\n\tprivate minimum: number\n\tprivate maximum: number\n\toverCap: number = 0\n\tprivate correctHistory: boolean\n\tprivate deterministic: boolean\n\n\tprivate chartOptions?: CounterChartOptions\n\tprivate graphOptions?: GaugeGraphOptions\n\n\tpublic history: CounterHistory[] = []\n\n\tget value(): number {\n\t\treturn this._value\n\t}\n\n\tget capped(): boolean {\n\t\treturn this._value >= this.maximum\n\t}\n\n\tget empty(): boolean {\n\t\treturn this._value <= this.minimum\n\t}\n\n\tget totalSpent(): number {\n\t\treturn this.history.filter(entry => entry.reason === 'spend').reduce((total, entry) => total + Math.abs(entry.delta), 0)\n\t}\n\n\tget totalGenerated(): number {\n\t\treturn this.history.filter(entry => entry.reason === 'generate').reduce((total, entry) => total + Math.abs(entry.delta), 0)\n\t}\n\n\tconstructor(opts: CounterGaugeOptions = {}) {\n\t\tsuper(opts)\n\n\t\tthis.minimum = opts.minimum ?? 0\n\t\tthis.initialValue = opts.initialValue ?? this.minimum\n\t\tthis._value = this.initialValue\n\t\tthis.maximum = opts.maximum ?? 100\n\t\tthis.correctHistory = opts.correctHistory ?? false\n\t\tthis.deterministic = opts.deterministic ?? true\n\n\t\tthis.chartOptions = opts.chart\n\t\tthis.graphOptions = opts.graph\n\t}\n\n\tgetValueAt(timestamp: number) {\n\t\tconst counter = _.findLast(this.history, gauge => gauge.timestamp <= timestamp)\n\t\treturn counter? counter.value : this.minimum\n\t}\n\n\t/** @inheritdoc */\n\treset() {\n\t\t// NOTE: This assumes counters always reset to their minimum value.\n\t\t// Should that not be the case, probbaly needs a `resetTo` value.\n\t\tthis.set(this.minimum, 'reset')\n\t}\n\n\traise() {\n\t\tthis.set(this.minimum, 'init')\n\t}\n\n\tinit() {\n\t\t// Ensure we have a gauge init event, can't do in constructor because the parser reference might not be there yet\n\t\tif (this.history.length === 0) {\n\t\t\tthis.history.push({\n\t\t\t\ttimestamp: this.parser.pull.timestamp,\n\t\t\t\tvalue: this.initialValue,\n\t\t\t\tminimum: this.minimum,\n\t\t\t\tmaximum: this.maximum,\n\t\t\t\tdelta: 0,\n\t\t\t\treason: 'init',\n\t\t\t})\n\t\t}\n\t}\n\n\t/** Modify the current value by the provided amount. Equivalent to `set(currentValue + amount)` */\n\tmodify(amount: number) {\n\t\tthis.set(this._value + amount)\n\t}\n\n\t/** Increase the current value by the provided amount. */\n\tgenerate = (amount: number) => this.modify(amount)\n\n\t/** Decrease the current value by the provided amount. */\n\tspend = (amount: number) => this.modify(-amount)\n\n\t/** Set the current value of the gauge. Value will automatically be bounded to valid values. Value over the maximum will be tracked as overcap. */\n\tset(value: number, reason?: GaugeEventReason) {\n\t\tconst delta = value - this.value\n\n\t\tconst _reason = reason ?? delta > 0 ? 'generate' : 'spend'\n\n\t\tconst newValue = Math.min(Math.max(value, this.minimum), this.maximum)\n\n\t\tconst diff = value - newValue\n\t\tif (diff > 0) {\n\t\t\tthis.overCap += diff\n\t\t} else if (diff < 0 && this.correctHistory) {\n\t\t\tthis.correctGaugeHistory(delta, this._value)\n\t\t}\n\n\t\tthis._value = newValue\n\t\tthis.pushHistory(_reason, delta)\n\t}\n\n\tprivate correctGaugeHistory(spenderCost: number, currentGauge: number) {\n\t\tspenderCost = Math.abs(spenderCost)\n\n\t\t// Get the most recent initialisation event (or generation event if this gauge isn't deterministic) we've recorded\n\t\tconst lastGeneratorIndex = _.findLastIndex(this.history, event => (!this.deterministic && event.reason === 'generate') || event.reason === 'init')\n\n\t\t// Add the amount we underran the simulation by to the last generation event, and all events through the current one\n\t\tconst underrunAmount = Math.abs(currentGauge - spenderCost)\n\t\tfor (let i = lastGeneratorIndex; i < this.history.length; i++) {\n\t\t\tthis.history[i].value += underrunAmount\n\t\t}\n\n\t\t// If the last generator was also the first event (dungeons with stocked resources, etc.), we're done\n\t\tif (lastGeneratorIndex === 0) {\n\t\t\treturn\n\t\t}\n\n\t\t// Find the last non-generation event previous to the last generator we already found, and smooth the graph between the two events by adding a proportional amount of the underrun value to each event\n\t\tconst previousSpenderIndex = _.findLastIndex(this.history.slice(0, lastGeneratorIndex), event => event.reason !== 'generate')\n\t\tconst adjustmentPerEvent = underrunAmount / (lastGeneratorIndex - previousSpenderIndex)\n\t\tfor (let i = previousSpenderIndex + 1; i < lastGeneratorIndex; i ++) {\n\t\t\tthis.history[i].value += adjustmentPerEvent * (i - previousSpenderIndex)\n\t\t}\n\t}\n\n\t/** Set a new minimum value for the gauge. Equivalent to `setBounds(newMin, currentMax)`. */\n\tsetMinimum(minimum: number) {\n\t\tthis.setBounds(minimum, this.maximum)\n\t}\n\n\t/** Set a new maximum value for the gauge. Equivalent to `setBounds(currentMin, newMax)`. */\n\tsetMaximum(maximum: number) {\n\t\tthis.setBounds(this.minimum, maximum)\n\t}\n\n\t/** Set new bounds for the gauge. If required, the current value will be updated to remain within bounds. */\n\tsetBounds(minimum: number, maximum: number) {\n\t\tthis.minimum = minimum\n\t\tthis.maximum = maximum\n\n\t\t// Ensure the value remains within bounds by re-setting it\n\t\tthis.set(this._value, 'changeBounds')\n\t}\n\n\tprivate pushHistory(reason: GaugeEventReason, delta: number) {\n\t\tconst timestamp = this.parser.currentEpochTimestamp\n\n\t\t// Ensure we're not generating multiple entries at the same timestamp\n\t\tconst prevTimestamp = this.history.length\n\t\t\t? this.history[this.history.length - 1].timestamp\n\t\t\t: NaN\n\t\tif (timestamp === prevTimestamp) {\n\t\t\tconst prevEvent = this.history.pop()\n\t\t\t// If we already spent or intitialised gauge at this timestamp, retain the reason to keep from backtracking past it\n\t\t\tif (prevEvent?.reason === 'spend' || prevEvent?.reason === 'init') {\n\t\t\t\treason = prevEvent.reason\n\t\t\t}\n\t\t}\n\n\t\tthis.history.push({\n\t\t\ttimestamp,\n\t\t\tvalue: this._value,\n\t\t\tminimum: this.minimum,\n\t\t\tmaximum: this.maximum,\n\t\t\tdelta,\n\t\t\treason,\n\t\t})\n\t}\n\n\t/** @inheritdoc */\n\toverride generateResourceGraph() {\n\t\tif (this.graphOptions == null) { return }\n\n\t\tconst {handle, color, label} = this.graphOptions\n\t\tconst graphData = {\n\t\t\tlabel,\n\t\t\tcolour: color,\n\t\t\tdata: this.history.map(entry => {\n\t\t\t\treturn {time: entry.timestamp, current: entry.value, maximum: entry.maximum}\n\t\t\t}),\n\t\t}\n\t\tif (handle != null) {\n\t\t\tthis.resourceGraphs.addDataGroup({...this.graphOptions, handle})\n\t\t\tthis.resourceGraphs.addData(handle, graphData)\n\t\t} else {\n\t\t\tthis.resourceGraphs.addGauge(graphData, {...this.graphOptions, handle: GAUGE_HANDLE})\n\t\t}\n\t}\n\n\t/** @inheritdoc */\n\toverride generateDataset() {\n\t\t// If there's no chart options, or if there are graph options, provide nothing (prefer graph)\n\t\tif (this.chartOptions == null || this.graphOptions != null) {\n\t\t\treturn\n\t\t}\n\n\t\t// Map the data into something the chart will understand\n\t\tconst data = this.history.map(entry => ({\n\t\t\tt: entry.timestamp - this.parser.pull.timestamp,\n\t\t\ty: entry.value,\n\t\t}))\n\n\t\t// Build the final data set\n\t\tconst {label, color} = this.chartOptions\n\t\tconst dataSet: ChartDataSets = {\n\t\t\tlabel,\n\t\t\tdata,\n\t\t\tsteppedLine: true,\n\t\t}\n\n\t\tif (color) {\n\t\t\t/* eslint-disable @typescript-eslint/no-magic-numbers */\n\t\t\tconst chartColor = Color(color)\n\t\t\tdataSet.backgroundColor = chartColor.fade(0.8).toString()\n\t\t\tdataSet.borderColor = chartColor.fade(0.5).toString()\n\t\t\t/* eslint-enable @typescript-eslint/no-magic-numbers */\n\t\t}\n\n\t\treturn dataSet\n\t}\n}\n"],"names":["AbstractGauge","opts","_parser","_resourceGraphs","this","parser","Error","resourceGraphs","DEFAULT_OPTIONS","aspectRatio","scales","xAxes","type","time","displayFormats","minute","second","millisecond","tooltipFormat","TimeLineChart","options","props","data","width","height","PureComponent","PAUSES_TIMER_GAUGE_STATUSES","Gauge","ResourceGraphs","Data","gauges","addEventHook","actor","id","onDeath","onRaise","pauseTimerFilter","filter","target","status","matchStatusId","onPauseTimers","onResumeTimers","forEach","gauge","generateResourceGraph","setParser","TimerGauge","setAddTimestampHook","addTimestampHook","bind","setRemoveTimestampHook","removeTimestampHook","setResourceGraphs","init","push","_event","reset","raise","paused","pause","resume","datasets","generateDataset","isDefined","length","Analyser","handle","title","dependency","expectExist","value","minimum","maximum","expirationCallback","graphOptions","hook","history","_addTimestampHook","_removeTimestampHook","onExpiration","args","timestamp","currentEpochTimestamp","remaining","graph","lastKnownState","delta","Math","max","expired","set","onlyIfRunning","start","duration","min","graphData","label","colour","color","entry","current","linear","addDataGroup","addData","addGauge","GAUGE_HANDLE","pull","end","downtimeWindows","reapplyAfterDowntime","currentStart","undefined","expirationWindows","expirations","expiration","uta","when","internalExpirationTime","totalExpiration","currentWindow","windows","window","CounterGauge","initialValue","_value","overCap","correctHistory","deterministic","chartOptions","generate","amount","modify","spend","chart","reason","total","abs","counter","_reason","newValue","diff","correctGaugeHistory","pushHistory","spenderCost","currentGauge","lastGeneratorIndex","event","underrunAmount","i","previousSpenderIndex","adjustmentPerEvent","setBounds","NaN","prevEvent","pop","t","y","dataSet","steppedLine","chartColor","Color","backgroundColor","fade","toString","borderColor"],"sourceRoot":""}