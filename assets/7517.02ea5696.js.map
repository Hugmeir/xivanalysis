{"version":3,"file":"assets/7517.02ea5696.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/components/ui/RotationTable.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/History.ts","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/ExpectedGcdCountEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/AllowedGcdsOnlyEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/ExpectedActionsEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/ExpectedActionGroupsEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/LimitedActionsEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/PlayersBuffedEvaluator.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/evaluators/NotesEvaluator.ts","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/windows/RaidBuffWindow.ts","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/windows/ActionWindow.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionWindow/windows/BuffWindow.ts","webpack://@xivanalysis/client/./node_modules/lodash/first.js","webpack://@xivanalysis/client/./node_modules/lodash/head.js","webpack://@xivanalysis/client/./node_modules/lodash/max.js"],"sourcesContent":["import {Trans} from '@lingui/react'\nimport Rotation, {RotationEvent} from 'components/ui/Rotation'\nimport React from 'react'\nimport {Button, Table} from 'semantic-ui-react'\nimport {isDefined, formatDuration} from 'utilities'\n\nexport interface RotationTarget {\n\t/**\n\t * Displayed header\n\t */\n\theader: React.ReactNode\n\t/**\n\t * Accessor can either be a string, in which case this will resolve to the value assigned to the same key in the `targetsData` field in each entry,\n\t * or a function resolving the entry to the `RotationTargetData`.\n\t */\n\taccessor: string | ((entry: RotationTableEntry) => RotationTargetData)\n}\n\nexport interface RotationNotes {\n\t/**\n\t * Displayed header\n\t */\n\theader: React.ReactNode\n\t/**\n\t * Accessor can either be a string, in which case this will resolve to the value assigned to the same key in the `targetsData` field in each entry,\n\t * or a function resolving the entry to the `RotationTargetData`.\n\t */\n\taccessor: string | ((entry: RotationTableEntry) => React.ReactNode)\n}\n\n/**\n * Determines how a rotation target gets highlighted (negative = red, positive = green)\n */\nexport enum RotationTargetOutcome { NEGATIVE, NEUTRAL, POSITIVE }\n\nexport interface RotationTargetData {\n\t/**\n\t * Expected target number\n\t */\n\texpected?: number\n\t/**\n\t * Recorded number\n\t */\n\tactual: number\n\t/**\n\t * Optional function to override the default positive/negative highlighting\n\t */\n\ttargetComparator?: (actual: number, expected?: number) => RotationTargetOutcome\n}\n\nexport interface RotationTableTargetData {\n\t/**\n\t * Identifier to Target Data mapping\n\t */\n\t[id: string]: RotationTargetData\n}\n\nexport interface RotationTableNotesMap {\n\t/**\n\t * Identifier to Notes mapping\n\t */\n\t[id: string]: React.ReactNode\n}\n\nexport interface RotationTableEntry {\n\t/**\n\t * Start point relative to fight start\n\t */\n\tstart: number\n\t/**\n\t * End point relative to fight start\n\t */\n\tend: number\n\t/**\n\t * Map of pre calculated target data\n\t */\n\ttargetsData?: RotationTableTargetData\n\t/**\n\t * Map of pre calculated target data\n\t */\n\tnotesMap?: RotationTableNotesMap\n\t/**\n\t * Rotation to display that occurs during this entry\n\t */\n\trotation: RotationEvent[]\n}\n\ninterface RotationTableProps {\n\t/**\n\t * List of Targets to display, consisting of the displayed header and the accessor to resolve the actual and expected values\n\t */\n\ttargets?: RotationTarget[]\n\t/**\n\t * List of Notes to display, consisting of the displayed header and the accessor to resolve the value\n\t */\n\tnotes?: RotationNotes[]\n\t/**\n\t * List of table entries, consisting of a time frame and the rotation, with optionally a pre calculated target data\n\t */\n\tdata: RotationTableEntry[]\n\t/**\n\t * Optional Callback to display the jump to time button.\n\t * Usually this should be a pass through of the `Timeline.show` function.\n\t * @param start\n\t * @param end\n\t * @param scrollTo\n\t */\n\tonGoto?: (start: number, end: number, scrollTo?: boolean) => void\n\t/**\n\t * Optional property to provide a JSX.Element (translation tag) for the header value.\n\t * Defaults to \"Rotation\"\n\t */\n\theaderTitle?: JSX.Element\n}\n\ninterface RotationTableRowProps {\n\t/**\n\t * List of Targets to display, consisting of the displayed header and the accessor to resolve the actual and expected values\n\t */\n\ttargets: RotationTarget[]\n\t/**\n\t * List of Notes to display, consisting of the displayed header and the accessor to resolve the value\n\t */\n\tnotes: RotationNotes[]\n\t/**\n\t * Optional Callback to display the jump to time button.\n\t * Usually this should be a pass through of the `Timeline.show` function.\n\t * @param start\n\t * @param end\n\t * @param scrollTo\n\t */\n\tonGoto?: (start: number, end: number, scrollTo?: boolean) => void\n}\n\nexport class RotationTable extends React.Component<RotationTableProps> {\n\tstatic defaultTargetComparator(actual: number, expected?: number): RotationTargetOutcome {\n\t\tif (!isDefined(expected)) {\n\t\t\treturn RotationTargetOutcome.NEUTRAL\n\t\t}\n\n\t\tif (actual >= expected) {\n\t\t\treturn RotationTargetOutcome.POSITIVE\n\t\t}\n\n\t\treturn RotationTargetOutcome.NEGATIVE\n\t}\n\n\tstatic targetAccessorResolver = (entry: RotationTableEntry, target: RotationTarget): RotationTargetData => {\n\t\tif (typeof target.accessor === 'string' && entry.targetsData != null) {\n\t\t\treturn entry.targetsData[target.accessor]\n\t\t}\n\n\t\tif (typeof target.accessor === 'function') {\n\t\t\treturn target.accessor(entry)\n\t\t}\n\n\t\treturn {\n\t\t\tactual: 0,\n\t\t\texpected: 0,\n\t\t}\n\t}\n\n\tstatic notesAccessorResolver = (entry: RotationTableEntry, note: RotationNotes): React.ReactNode => {\n\t\tif (typeof note.accessor === 'string' && entry.notesMap != null) {\n\t\t\treturn entry.notesMap[note.accessor]\n\t\t}\n\n\t\tif (typeof note.accessor === 'function') {\n\t\t\treturn note.accessor(entry)\n\t\t}\n\n\t\treturn null\n\t}\n\n\tstatic TargetCell = ({actual, expected, targetComparator}: RotationTargetData) => {\n\t\tif (targetComparator === undefined) {\n\t\t\ttargetComparator = RotationTable.defaultTargetComparator\n\t\t}\n\t\tconst targetOutcome = targetComparator(actual, expected)\n\n\t\treturn <Table.Cell\n\t\t\ttextAlign=\"center\"\n\t\t\tpositive={targetOutcome === RotationTargetOutcome.POSITIVE}\n\t\t\tnegative={targetOutcome === RotationTargetOutcome.NEGATIVE}\n\t\t>\n\t\t\t{actual}/{expected === undefined ? '-' : expected}\n\t\t</Table.Cell>\n\t}\n\n\tstatic Row = ({onGoto, targets, notes, notesMap, start, end, targetsData, rotation}: RotationTableRowProps & RotationTableEntry) =>\n\t\t<Table.Row>\n\t\t\t<Table.Cell textAlign=\"center\">\n\t\t\t\t<span style={{marginRight: 5}}>{formatDuration(start, {secondPrecision: 0})}</span>\n\t\t\t\t{typeof onGoto === 'function' && <Button\n\t\t\t\t\tcircular\n\t\t\t\t\tcompact\n\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\ticon=\"time\"\n\t\t\t\t\tonClick={() => onGoto(start, end)}\n\t\t\t\t/>}\n\t\t\t</Table.Cell>\n\t\t\t{\n\t\t\t\ttargets\n\t\t\t\t\t.map(target => RotationTable.targetAccessorResolver({start, end, targetsData, rotation}, target))\n\t\t\t\t\t.map((targetEntry, i) => <RotationTable.TargetCell key={`target_${i}`} {...targetEntry}/>)\n\t\t\t}\n\t\t\t<Table.Cell>\n\t\t\t\t<Rotation events={rotation}/>\n\t\t\t</Table.Cell>\n\t\t\t{\n\t\t\t\tnotes\n\t\t\t\t\t.map(note => RotationTable.notesAccessorResolver({start, end, targetsData, notesMap, rotation}, note))\n\t\t\t\t\t.map((noteEntry, i) =>\n\t\t\t\t\t\t<Table.Cell\n\t\t\t\t\t\t\tkey={`notes_${i}`}\n\t\t\t\t\t\t\ttextAlign=\"center\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{noteEntry}\n\t\t\t\t\t\t</Table.Cell>,\n\t\t\t\t\t)\n\t\t\t}\n\t\t</Table.Row>\n\n\toverride render(): React.ReactNode {\n\t\tconst {\n\t\t\ttargets,\n\t\t\tnotes,\n\t\t\tdata,\n\t\t\tonGoto,\n\t\t\theaderTitle,\n\t\t} = this.props\n\n\t\treturn <Table compact unstackable celled>\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.rotation-table.header.time\">Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{\n\t\t\t\t\t\t(targets || []).map((target, i) =>\n\t\t\t\t\t\t\t<Table.HeaderCell key={`target_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{target.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong>{(headerTitle)? headerTitle : <Trans id=\"core.ui.rotation-table.header.rotation\">Rotation</Trans>}</strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t{\n\t\t\t\t\t\t(notes || []).map((note, i) =>\n\t\t\t\t\t\t\t<Table.HeaderCell key={`note_header_${i}`} textAlign=\"center\" collapsing>\n\t\t\t\t\t\t\t\t<strong>{note.header}</strong>\n\t\t\t\t\t\t\t</Table.HeaderCell>,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{\n\t\t\t\t\tdata.map((entry) =>\n\t\t\t\t\t\t<RotationTable.Row key={entry.start} onGoto={onGoto} targets={targets || []} notes={notes || []} {...entry}/>,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t</Table.Body>\n\t\t</Table>\n\t}\n}\n","import _ from 'lodash'\n\nexport interface HistoryEntry<T> {\n\t/**\n\t * The timestamp at which the entry started.\n\t */\n\tstart: number\n\t/**\n\t * The timestamp at which the entry ended or undefined if the entry is open.\n\t */\n\tend?: number\n\t/**\n\t * The data for this entry.\n\t */\n\tdata: T\n}\n\nexport class History<T> {\n\n\t/**\n\t * Contains all entries created by the tracker.\n\t */\n\tpublic entries: Array<HistoryEntry<T>> = []\n\n\tprivate dataInitializer: () => T\n\n\t/**\n\t * Creates a tracker with the specified initialization function\n\t * @param initializer Creates data for a new entry when one is opened.\n\t */\n\tconstructor(initializer: () => T) {\n\t\tthis.dataInitializer = initializer\n\t}\n\n\t/**\n\t * Gets the currently open entry or returns undefined if there is\n\t * no currently open entry.\n\t */\n\tpublic getCurrent() {\n\t\tconst last = _.last(this.entries)\n\t\tif (last != null && last.end == null) {\n\t\t\treturn last\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Executes an action on the current entry's data if an entry is currently open.\n\t * @param action The action to be executed on the data of the open entry. Ignored if no entry is open.\n\t */\n\tpublic doIfOpen(action: (current: T) => void) {\n\t\tconst current = this.getCurrent()\n\t\tif (current != null) { action(current.data) }\n\t}\n\n\t/**\n\t * Opens a new entry at the specified time and closes any\n\t * previously active entry.\n\t * @param timestamp The timestamp at which the new entry will be started.\n\t */\n\tpublic openNew(timestamp: number) {\n\t\tthis.closeCurrent(timestamp)\n\t\treturn this.open(timestamp)\n\t}\n\n\t/**\n\t * Gets the currently open entry if there is one or opens a new\n\t * entry if there is no currently open entry.\n\t * @param timestamp The timestamp at which a new entry will be started if a new one is opened.\n\t */\n\tpublic getCurrentOrOpenNew(timestamp: number) {\n\t\treturn this.getCurrent() ?? this.open(timestamp)\n\t}\n\n\t/**\n\t * Closes the current entry.\n\t * If the most recent entry is already closed, no action is taken\n\t * @param timestamp The timestamp at which the entry is closed.\n\t */\n\tpublic closeCurrent(timestamp: number) {\n\t\tconst current = this.getCurrent()\n\t\tif (current != null) { current.end = timestamp }\n\t}\n\n\t/**\n\t * Reopens the last entry and returns it.\n\t * If the previous entry was still open, returns the entry as is.\n\t * If there is no previous entry, does nothing and returns undefined.\n\t */\n\tpublic reopenLastEntry() {\n\t\tconst last = _.last(this.entries)\n\t\tif (last != null) {\n\t\t\tlast.end = undefined\n\t\t}\n\t\treturn last\n\t}\n\n\t/**\n\t * Returns the end of the last entry.\n\t * If there is no previous entry or if the current entry is still open,\n\t * returns undefined\n\t */\n\tpublic endOfLastEntry() {\n\t\tconst last = _.last(this.entries)\n\t\tif (last != null) {\n\t\t\treturn last.end\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Opens a new entry and adds it to the history.\n\t * Assumes any existing entry has been closed.\n\t * @param timestamp The timestamp at which the entry is opened.\n\t * @returns The new entry\n\t */\n\tprivate open(timestamp: number) {\n\t\tconst current: HistoryEntry<T> = {start: timestamp, data: this.dataInitializer()}\n\n\t\tthis.entries.push(current)\n\t\treturn current\n\t}\n\n}\n","import {Plural, Trans} from '@lingui/react'\nimport React from 'react'\nimport {GlobalCooldown} from '../../GlobalCooldown'\nimport {SeverityTiers, TieredSuggestion} from '../../Suggestions/Suggestion'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {EvaluationOutput, WindowEvaluator} from './WindowEvaluator'\n\n// Extremely conservative weave delay to prevent\n// any possibility of undercounting expected GCDs\nconst weaveDelay = 250\n\n// exported for use in AllowedGcdsOnlyEvaluator\nexport function calculateExpectedGcdsForTime(defaultExpected: number, gcdEstimate: number, start: number, end?: number) {\n\treturn Math.min(defaultExpected, Math.ceil(((end ?? start) - start) / gcdEstimate))\n}\n\ninterface ExpectedGcdCountOptions {\n\texpectedGcds: number\n\t/**\n\t * This should be the globalCooldown dependency object.\n\t * It is used by this class to perform end of fight gcd count adjustment.\n\t */\n\tglobalCooldown: GlobalCooldown\n\thasStacks: boolean\n\tsuggestionIcon: string\n\tsuggestionContent: JSX.Element\n\t/**\n\t * This is the name of the window used in the why portion of suggestions generated by these evaluators.\n\t * A DataLink with showIcon={false} or a Trans tag with an alternate name is recommended.\n\t */\n\tsuggestionWindowName: JSX.Element\n\tseverityTiers: SeverityTiers\n\t/**\n\t * This method MAY be provided to adjust the default number of expected GCDs, as calculated based on\n\t * the provided baseline and window duration.\n\t * This method is NOT responsible for calculating reductions due to end of fight rushing.\n\t * @param window The window for which the expected GCD count will be adjusted\n\t * @returns An adjustment to add to the baseline expected GCD count. A positive number INCREASES the\n\t * number of expected GCDs; a negative number DECREASES the number of expected GCDs\n\t */\n\tadjustCount?: (window: HistoryEntry<EvaluatedAction[]>) => number\n}\n/**\n * Checks if a window contains the maximum possible number of GCDs based on the estimated GCD speed.\n * All GCDs used in the window will be counted towards the total.\n */\nexport class ExpectedGcdCountEvaluator implements WindowEvaluator {\n\n\tprivate expectedGcds: number\n\tprivate globalCooldown: GlobalCooldown\n\tprivate hasStacks: boolean\n\tprivate suggestionIcon: string\n\tprivate suggestionContent: JSX.Element\n\tprivate suggestionWindowName: JSX.Element\n\tprivate severityTiers: SeverityTiers\n\tprivate adjustCount: (window: HistoryEntry<EvaluatedAction[]>) => number\n\n\tconstructor(opts: ExpectedGcdCountOptions) {\n\t\tthis.expectedGcds = opts.expectedGcds\n\t\tthis.globalCooldown = opts.globalCooldown\n\t\tthis.hasStacks = opts.hasStacks\n\t\tthis.suggestionIcon = opts.suggestionIcon\n\t\tthis.suggestionContent = opts.suggestionContent\n\t\tthis.suggestionWindowName = opts.suggestionWindowName\n\t\tthis.severityTiers = opts.severityTiers\n\t\tthis.adjustCount = opts.adjustCount ?? (() => 0)\n\t}\n\n\tpublic suggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst missedGCDs = windows.reduce((acc, window) => acc + this.calculateMissingGcdsForWindow(window), 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: missedGCDs,\n\t\t\twhy: <Trans id=\"core.buffwindow.suggestions.missedgcd.why\">\n\t\t\t\t<Plural value={missedGCDs} one=\"# GCD was\" other=\"# GCDs were\" /> missed during {this.suggestionWindowName} windows.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput  {\n\t\treturn {\n\t\t\tformat: 'table',\n\t\t\theader: {\n\t\t\t\theader: <Trans id=\"core.buffwindow.table.header.gcds\">GCDs</Trans>,\n\t\t\t\taccessor: 'missedgcd',\n\t\t\t},\n\t\t\trows: windows.map(window => {\n\t\t\t\treturn {\n\t\t\t\t\tactual: this.countGcdsInWindow(window),\n\t\t\t\t\texpected: this.calculateExpectedGcdsForWindow(window),\n\t\t\t\t}\n\t\t\t}),\n\t\t}\n\t}\n\n\tprivate calculateMissingGcdsForWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\tconst expected = this.calculateExpectedGcdsForWindow(window)\n\t\tconst actual = this.countGcdsInWindow(window)\n\t\treturn Math.max(0, expected - actual)\n\t}\n\n\t// Buffs with stacks have durations tightly coupled to the GCD\n\t// and do not benefit from accounting for weave delay\n\tprivate calculateExpectedGcdsForWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\tlet adjustedStart = window.start\n\n\t\tif (!this.hasStacks) {\n\t\t\tadjustedStart += weaveDelay\n\t\t}\n\n\t\treturn calculateExpectedGcdsForTime(this.expectedGcds, this.globalCooldown.getDuration(), adjustedStart, window.end) + this.adjustCount(window)\n\t}\n\n\tprivate countGcdsInWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\treturn window.data.filter(cast => cast.action.onGcd).length\n\t}\n\n}\n","import {Plural, Trans} from '@lingui/react'\nimport React from 'react'\nimport {GlobalCooldown} from '../../GlobalCooldown'\nimport {SeverityTiers, TieredSuggestion} from '../../Suggestions/Suggestion'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {calculateExpectedGcdsForTime} from './ExpectedGcdCountEvaluator'\nimport {EvaluationOutput, WindowEvaluator} from './WindowEvaluator'\n\nexport interface AllowedGcdsOnlyOptions {\n\texpectedGcdCount: number\n\tallowedGcds: number[]\n\t/**\n\t * This should be the globalCooldown dependency object.\n\t * It is used by this class to perform end of fight gcd count adjustment.\n\t */\n\tglobalCooldown: GlobalCooldown\n\tsuggestionIcon: string\n\tsuggestionContent: JSX.Element\n\t/**\n\t * This is the name of the window used in the why portion of suggestions generated by these evaluators.\n\t * A DataLink with showIcon={false} or a Trans tag with an alternate name is recommended.\n\t */\n\tsuggestionWindowName: JSX.Element\n\tseverityTiers: SeverityTiers\n\t/**\n\t * This method MAY be provided to adjust the default number of expected GCDs, as calculated based on\n\t * the provided baseline and window duration.\n\t * This method is NOT responsible for calculating reductions due to end of fight rushing.\n\t * @param window The window for which the expected GCD count will be adjusted\n\t * @returns An adjustment to add to the baseline expected GCD count. A positive number INCREASES the\n\t * number of expected GCDs; a negative number DECREASES the number of expected GCDs\n\t */\n\tadjustCount?: (window: HistoryEntry<EvaluatedAction[]>) => number\n}\n/**\n * Checks if all GCDs in a window are one of the allowed GCDs.\n * This should be used for windows that contain repeated use of only few GCDs,\n * such as DRK's Delirium.  Use ExpectedActionsEvaluator instead for something\n * like PLD's Requiescat window that requires specific numbers of different GCDs.\n */\nexport class AllowedGcdsOnlyEvaluator implements WindowEvaluator {\n\n\tprivate expectedGcdCount: number\n\tprotected allowedGcds: number[]\n\tprotected globalCooldown: GlobalCooldown\n\tprotected suggestionIcon: string\n\tprotected suggestionContent: JSX.Element\n\tprotected suggestionWindowName: JSX.Element\n\tprotected severityTiers: SeverityTiers\n\tprivate adjustCount: (window: HistoryEntry<EvaluatedAction[]>) => number\n\n\tconstructor(opts: AllowedGcdsOnlyOptions) {\n\t\tthis.expectedGcdCount = opts.expectedGcdCount\n\t\tthis.allowedGcds = opts.allowedGcds\n\t\tthis.globalCooldown = opts.globalCooldown\n\t\tthis.suggestionIcon = opts.suggestionIcon\n\t\tthis.suggestionContent = opts.suggestionContent\n\t\tthis.suggestionWindowName = opts.suggestionWindowName\n\t\tthis.severityTiers = opts.severityTiers\n\t\tthis.adjustCount = opts.adjustCount ?? (() => 0)\n\t}\n\n\t// This calculation method is brought in from BuffWindow and is done this way because the\n\t// table output lists x/y in a column to show that <required skill> was used x times out of the\n\t// expected y times (the possible number of gcds) in a given window.\n\tpublic suggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst invalidGCDs = windows.reduce((acc, window) => acc + this.calculateBadGcdsForWindow(window), 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: invalidGCDs,\n\t\t\twhy: <Trans id=\"core.buffwindow.suggestions.badgcd.why\">\n\t\t\t\t<Plural value={invalidGCDs} one=\"# incorrect GCD was\" other=\"# incorrect GCDs were\" /> used during {this.suggestionWindowName} windows.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput  {\n\t\treturn {\n\t\t\tformat: 'table',\n\t\t\theader: {\n\t\t\t\theader: <img src={this.suggestionIcon} alt=\"\" style={{height: '20px'}}/>,\n\t\t\t\taccessor: 'badgcd',\n\t\t\t},\n\t\t\trows: windows.map(window => {\n\t\t\t\treturn {\n\t\t\t\t\tactual: this.countAllowedGcdsInWindow(window),\n\t\t\t\t\texpected: this.calculateExpectedGcdsForWindow(window),\n\t\t\t\t}\n\t\t\t}),\n\t\t}\n\t}\n\n\tprivate calculateBadGcdsForWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\treturn window.data.filter(cast => cast.action.onGcd && !this.allowedGcds.includes(cast.action.id)).length\n\t}\n\n\tprotected calculateExpectedGcdsForWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\treturn calculateExpectedGcdsForTime(this.expectedGcdCount, this.globalCooldown.getDuration(), window.start, window.end) + this.adjustCount(window)\n\t}\n\n\tprivate countAllowedGcdsInWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\treturn window.data.filter(cast => cast.action.onGcd && this.allowedGcds.includes(cast.action.id)).length\n\t}\n\n}\n","import {Plural, Trans} from '@lingui/react'\nimport {ActionLink} from 'components/ui/DbLink'\nimport {RotationTargetOutcome} from 'components/ui/RotationTable'\nimport React from 'react'\nimport {SeverityTiers, TieredSuggestion} from '../../Suggestions/Suggestion'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {OutcomeCalculator, TrackedAction, TrackedActionsOptions} from './TrackedAction'\nimport {EvaluationOutput, WindowEvaluator} from './WindowEvaluator'\n\n/**\n * Checks if specific actions are used a minimum number of times in a window.\n */\nexport class ExpectedActionsEvaluator implements WindowEvaluator {\n\n\tprivate expectedActions: TrackedAction[]\n\tprivate suggestionIcon: string\n\tprivate suggestionContent: JSX.Element\n\tprivate suggestionWindowName: JSX.Element\n\tprivate severityTiers: SeverityTiers\n\tprivate adjustCount : (window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) => number\n\tprivate adjustOutcome : (window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) => OutcomeCalculator | undefined\n\n\tconstructor(opts: TrackedActionsOptions) {\n\t\tthis.expectedActions = opts.expectedActions\n\t\tthis.suggestionIcon = opts.suggestionIcon\n\t\tthis.suggestionContent = opts.suggestionContent\n\t\tthis.suggestionWindowName = opts.suggestionWindowName\n\t\tthis.severityTiers = opts.severityTiers\n\t\tthis.adjustCount = opts.adjustCount ?? (() => 0)\n\t\tthis.adjustOutcome = opts.adjustOutcome ?? (() => undefined)\n\t}\n\n\tpublic suggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst missedActions = windows\n\t\t\t.reduce((total, window) => {\n\t\t\t\tconst missingInWindow = this.expectedActions.reduce((subTotal, action) => {\n\t\t\t\t\tconst actual = this.countUsed(window, action)\n\t\t\t\t\tconst expected = this.determineExpected(window, action)\n\t\t\t\t\tconst comparator = this.adjustOutcome(window, action)\n\t\t\t\t\t// If a custom comparator is defined for this action, and it didn't return negative, don't count this window\n\t\t\t\t\tconst currentLoss = (comparator != null && comparator(actual, expected) !== RotationTargetOutcome.NEGATIVE) ?\n\t\t\t\t\t\t0 : Math.max(0, expected - actual)\n\t\t\t\t\treturn subTotal + currentLoss\n\t\t\t\t}, 0)\n\t\t\t\treturn total + missingInWindow\n\t\t\t}, 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: missedActions,\n\t\t\twhy: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended action was\" other=\"# uses of recommended actions were\"/> missed during {this.suggestionWindowName} windows.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\tprotected actionHeader(action: TrackedAction) {\n\t\treturn <ActionLink showName={false} {...action.action}/>\n\t}\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput[]  {\n\t\treturn this.expectedActions.map(action => {\n\t\t\treturn {\n\t\t\t\tformat: 'table',\n\t\t\t\theader: {\n\t\t\t\t\theader: this.actionHeader(action),\n\t\t\t\t\taccessor: action.action.name,\n\t\t\t\t},\n\t\t\t\trows: windows.map(window => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tactual: this.countUsed(window, action),\n\t\t\t\t\t\texpected: this.determineExpected(window, action),\n\t\t\t\t\t\ttargetComparator: this.adjustOutcome(window, action),\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t}\n\t\t})\n\t}\n\n\tprotected countUsed(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\treturn window.data.filter(cast => cast.action.id === action.action.id).length\n\t}\n\n\tprivate determineExpected(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\treturn action.expectedPerWindow + this.adjustCount(window, action)\n\t}\n}\n","import {Plural, Trans} from '@lingui/react'\nimport {ActionLink} from 'components/ui/DbLink'\nimport {RotationTargetOutcome} from 'components/ui/RotationTable'\nimport _ from 'lodash'\nimport React from 'react'\nimport {SeverityTiers, TieredSuggestion} from '../../Suggestions/Suggestion'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {OutcomeCalculator} from './TrackedAction'\nimport {TrackedActionGroup, TrackedActionGroupsOptions} from './TrackedActionGroup'\nimport {EvaluationOutput, WindowEvaluator} from './WindowEvaluator'\n\nexport class ExpectedActionGroupsEvaluator implements WindowEvaluator {\n\n\tprivate expectedActionGroups: TrackedActionGroup[]\n\tprivate suggestionIcon: string\n\tprivate suggestionContent: JSX.Element\n\tprivate suggestionWindowName: JSX.Element\n\tprivate severityTiers: SeverityTiers\n\tprivate adjustCount : (window: HistoryEntry<EvaluatedAction[]>, action: TrackedActionGroup) => number\n\tprivate adjustOutcome : (window: HistoryEntry<EvaluatedAction[]>, action: TrackedActionGroup) => OutcomeCalculator | undefined\n\n\tconstructor(opts: TrackedActionGroupsOptions) {\n\t\tthis.expectedActionGroups = opts.expectedActionGroups\n\t\tthis.suggestionIcon = opts.suggestionIcon\n\t\tthis.suggestionContent = opts.suggestionContent\n\t\tthis.suggestionWindowName = opts.suggestionWindowName\n\t\tthis.severityTiers = opts.severityTiers\n\t\tthis.adjustCount = opts.adjustCount ?? (() => 0)\n\t\tthis.adjustOutcome = opts.adjustOutcome ?? (() => undefined)\n\t}\n\n\tpublic suggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst missedActions = windows\n\t\t\t.reduce((total, window) => {\n\t\t\t\tconst missingInWindow = this.expectedActionGroups.reduce((subTotal, actionGroup) => {\n\t\t\t\t\tconst actual = this.countUsed(window, actionGroup)\n\t\t\t\t\tconst expected = this.determineExpected(window, actionGroup)\n\t\t\t\t\tconst comparator = this.adjustOutcome(window, actionGroup)\n\t\t\t\t\t// If a custom comparator is defined for this action, and it didn't return negative, don't count this window\n\t\t\t\t\tconst currentLoss = (comparator != null && comparator(actual, expected) !== RotationTargetOutcome.NEGATIVE) ?\n\t\t\t\t\t\t0 : Math.max(0, expected - actual)\n\t\t\t\t\treturn subTotal + currentLoss\n\t\t\t\t}, 0)\n\t\t\t\treturn total + missingInWindow\n\t\t\t}, 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: missedActions,\n\t\t\twhy: <Trans id=\"core.buffwindow.suggestions.trackedaction.why\">\n\t\t\t\t<Plural value={missedActions} one=\"# use of a recommended action was\" other=\"# uses of recommended actions were\"/> missed during {this.suggestionWindowName} windows.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput[]  {\n\t\treturn this.expectedActionGroups.map(actionGroup => {\n\t\t\tconst headerActions = actionGroup.actions.map((action, i) => {\n\t\t\t\treturn <>\n\t\t\t\t\t{ i > 0 && <> / </> }\n\t\t\t\t\t<ActionLink key={i} showName={false} {...action}/>\n\t\t\t\t</>\n\t\t\t})\n\n\t\t\treturn {\n\t\t\t\tformat: 'table',\n\t\t\t\theader: {\n\t\t\t\t\theader: <>{headerActions}</>,\n\t\t\t\t\taccessor: _.first(actionGroup.actions)?.name ?? '',\n\t\t\t\t},\n\t\t\t\trows: windows.map(window => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tactual: this.countUsed(window, actionGroup),\n\t\t\t\t\t\texpected: this.determineExpected(window, actionGroup),\n\t\t\t\t\t\ttargetComparator: this.adjustOutcome(window, actionGroup),\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t}\n\t\t})\n\t}\n\n\tprotected countUsed(window: HistoryEntry<EvaluatedAction[]>, actionGroup: TrackedActionGroup) {\n\t\treturn window.data.filter(cast => {\n\t\t\tfor (const action of actionGroup.actions) {\n\t\t\t\tif (cast.action.id === action.id) { return true }\n\t\t\t}\n\t\t\treturn false\n\t\t}).length\n\t}\n\n\tprivate determineExpected(window: HistoryEntry<EvaluatedAction[]>, action: TrackedActionGroup) {\n\t\treturn action.expectedPerWindow + this.adjustCount(window, action)\n\t}\n}\n","import {Plural, Trans} from '@lingui/react'\nimport React from 'react'\nimport {SeverityTiers, TieredSuggestion} from '../../Suggestions/Suggestion'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {TrackedAction, TrackedActionsOptions} from './TrackedAction'\nimport {WindowEvaluator} from './WindowEvaluator'\n\n/**\n * Checks if specific actions are used a maximum number of times in a window.\n * To check that an action is never used, set the expectedPerWindow to 0 for\n * that action.\n */\nexport class LimitedActionsEvaluator implements WindowEvaluator {\n\n\tprivate expectedActions: TrackedAction[]\n\tprivate suggestionIcon: string\n\tprivate suggestionContent: JSX.Element\n\tprivate suggestionWindowName: JSX.Element\n\tprivate severityTiers: SeverityTiers\n\tprivate adjustCount : (window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) => number\n\n\tconstructor(opts: TrackedActionsOptions) {\n\t\tthis.expectedActions = opts.expectedActions\n\t\tthis.suggestionIcon = opts.suggestionIcon\n\t\tthis.suggestionContent = opts.suggestionContent\n\t\tthis.suggestionWindowName = opts.suggestionWindowName\n\t\tthis.severityTiers = opts.severityTiers\n\t\tthis.adjustCount = opts.adjustCount ?? (() => 0)\n\t}\n\n\tpublic suggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst badActions = windows\n\t\t\t.reduce((total, window) => {\n\t\t\t\tconst missingInWindow = this.expectedActions.reduce((subTotal, action) => {\n\t\t\t\t\treturn subTotal + Math.max(0, this.countUsed(window, action) - (action.expectedPerWindow + this.adjustCount(window, action)))\n\t\t\t\t}, 0)\n\t\t\t\treturn total + missingInWindow\n\t\t\t}, 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: badActions,\n\t\t\twhy: <Trans id=\"core.buffwindow.suggestions.trackedbadaction.why\">\n\t\t\t\t<Plural value={badActions} one=\"# use of\" other=\"# uses of\"/> actions that should be avoided during {this.suggestionWindowName} windows.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\tpublic output(): undefined { return undefined }\n\n\tprivate countUsed(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\treturn window.data.filter(cast => cast.action.id === action.action.id).length\n\t}\n\n}\n","import {Trans} from '@lingui/react'\nimport {EvaluatedAction, EvaluationOutput, WindowEvaluator} from 'parser/core/modules/ActionWindow'\nimport {HistoryEntry} from 'parser/core/modules/ActionWindow/History'\nimport React from 'react'\n\ninterface TrackedBuffOpts {\n\texpectedCount: number,\n\taffectedPlayers: (window: HistoryEntry<EvaluatedAction[]>) => number\n}\n/**\n * Checks the number of people a buff hit per window against an expected count.\n */\nexport class PlayersBuffedEvaluator implements WindowEvaluator {\n\tprivate affectedPlayers: (window: HistoryEntry<EvaluatedAction[]>) => number\n\tprivate expectedCount: number\n\n\tconstructor(opts: TrackedBuffOpts) {\n\t\tthis.affectedPlayers = opts.affectedPlayers\n\t\tthis.expectedCount = opts.expectedCount\n\t}\n\n\t// this is purely informational\n\tpublic suggest() { return undefined }\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput | undefined {\n\t\tconst affected = windows.map(w => this.affectedPlayers(w))\n\t\treturn {\n\t\t\tformat: 'table',\n\t\t\theader: {\n\t\t\t\theader: <Trans id=\"core.raidbuffwindow.table.header.players\">Players Buffed</Trans>,\n\t\t\t\taccessor: 'buffed',\n\t\t\t},\n\t\t\trows: affected.map(a => {\n\t\t\t\treturn {\n\t\t\t\t\tactual: a,\n\t\t\t\t\texpected: this.expectedCount,\n\t\t\t\t}\n\t\t\t}),\n\t\t}\n\t}\n}\n","import {RotationTarget} from 'components/ui/RotationTable'\nimport {Suggestion} from '../../Suggestions'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {EvaluationOutput, WindowEvaluator} from './WindowEvaluator'\n\nexport abstract class NotesEvaluator implements WindowEvaluator {\n\n\tprotected abstract header : RotationTarget\n\tprotected abstract generateNotes(window: HistoryEntry<EvaluatedAction[]>): JSX.Element\n\n\tsuggest(_windows: Array<HistoryEntry<EvaluatedAction[]>>): Suggestion | undefined { return undefined }\n\n\tpublic output(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput  {\n\t\treturn {\n\t\t\tformat: 'notes',\n\t\t\theader: this.header,\n\t\t\trows: windows.map(window => this.generateNotes(window)),\n\t\t}\n\t}\n}\n","import {Event, Events} from 'event'\nimport {BuffWindow, EvaluatedAction, PlayersBuffedEvaluator} from 'parser/core/modules/ActionWindow'\nimport {HistoryEntry} from 'parser/core/modules/ActionWindow/History'\nimport {ensureArray} from 'utilities'\nimport {filter, oneOf, noneOf} from '../../../filter'\n\n/**\n * Tracks buffs applied to the party.\n */\nexport abstract class RaidBuffWindow extends BuffWindow {\n\n\t/**\n\t * Array of all status apply events on players for the buffs specified.\n\t *\n\t * These might ideally belong in the History, but it would break the\n\t * current paradigm of the ActionWindow.\n\t */\n\tprotected raidBuffApplications = new Array<Events['statusApply']>()\n\n\t/**\n\t * Expected number of people who should get the raid buff every time.\n\t */\n\tprotected expectedCount = 0\n\n\toverride initialise() {\n\t\tsuper.initialise()\n\n\t\tconst partyMembers = this.parser.pull.actors\n\t\t\t.filter(actor => actor.playerControlled)\n\t\t\t.map(actor => actor.id)\n\t\tthis.expectedCount = partyMembers.length\n\t\tconst playerOwnedIds = this.parser.pull.actors\n\t\t\t.filter(actor => (actor.owner === this.parser.actor) || actor === this.parser.actor)\n\t\t\t.map(actor => actor.id)\n\t\tconst statusFilter = filter<Event>()\n\t\t\t.type('statusApply')\n\t\t\t.status(oneOf(ensureArray(this.buffStatus).map(s => s.id)))\n\n\t\tthis.addEventHook(\n\t\t\tstatusFilter\n\t\t\t\t.source(oneOf(playerOwnedIds))\n\t\t\t\t.target(oneOf(partyMembers)),\n\t\t\tthis.onRaidBuffApply\n\t\t)\n\n\t\t// Duplicate jobs can override buffs\n\t\tthis.addEventHook(\n\t\t\tstatusFilter\n\t\t\t\t.source(noneOf(playerOwnedIds))\n\t\t\t\t.target(this.parser.actor.id),\n\t\t\tthis.maybeReOpenPreviousWindow\n\t\t)\n\n\t\tthis.addEvaluator(new PlayersBuffedEvaluator({\n\t\t\texpectedCount: this.expectedCount,\n\t\t\taffectedPlayers: this.affectedPlayers.bind(this),\n\t\t}))\n\t}\n\n\tprivate onRaidBuffApply(event: Events['statusApply']) {\n\t\tthis.raidBuffApplications.push(event)\n\t}\n\n\tprivate affectedPlayers(buffWindow: HistoryEntry<EvaluatedAction[]>): number {\n\t\tconst windowEnd = buffWindow?.end ?? buffWindow.start\n\t\t// count the number of applications that happened in the window\n\t\tconst affected = this.raidBuffApplications.filter(event => {\n\t\t\treturn (buffWindow.start <= event.timestamp &&\n\t\t\t\tevent.timestamp <= windowEnd)\n\t\t})\n\n\t\treturn affected.length\n\t}\n\n\tprivate maybeReOpenPreviousWindow(event: Events['statusApply']) {\n\t\t// If your buff was overridden, the end timestamp should match the overriding event.\n\t\tif (this.history.endOfLastEntry() === event.timestamp) {\n\t\t\tconst last = this.history.reopenLastEntry()\n\t\t\tif (last != null) {\n\t\t\t\tthis.startWindowAndTimeout(last.start)\n\t\t\t}\n\t\t}\n\t}\n}\n","import {RotationTable, RotationTableNotesMap, RotationTableTargetData} from 'components/ui/RotationTable'\nimport {Event, Events} from 'event'\nimport {dependency} from 'parser/core/Injectable'\nimport {Timeline} from 'parser/core/modules/Timeline'\nimport React from 'react'\nimport {ensureArray, isDefined} from 'utilities'\nimport {Analyser} from '../../../Analyser'\nimport {EventFilterPredicate, EventHook} from '../../../Dispatcher'\nimport {filter, noneOf, oneOf} from '../../../filter'\nimport {Data} from '../../Data'\nimport Suggestions from '../../Suggestions'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {EvaluationOutput, WindowEvaluator} from '../evaluators/WindowEvaluator'\nimport {History, HistoryEntry} from '../History'\n\n/**\n * Tracks actions that occur within a window.\n * By default, all actions cast during a window will be included.\n */\nexport abstract class ActionWindow extends Analyser {\n\n\t@dependency protected data!: Data\n\t@dependency private suggestions!: Suggestions\n\t@dependency private timeline!: Timeline\n\n\t/**\n\t * The captured windows.\n\t */\n\tprotected history = new History<Array<Events['action']>>(() => [])\n\t/**\n\t * The event filter used to capture events while a window is open.\n\t * The default filter will capture all actions.\n\t */\n\tprivate eventFilter: EventFilterPredicate<Events['action']> = filter<Event>().source(this.parser.actor.id).type('action')\n\t/**\n\t * The event hook for actions being captured.\n\t */\n\tprivate eventHook?: EventHook<Events['action']>\n\t/**\n\t * The evaluators used to generate suggestions and output for the windows.\n\t */\n\tprivate evaluators: WindowEvaluator[] = []\n\n\t/**\n\t * Implementing modules MAY provide a value to override the \"Rotation\" title in the header of the rotation section\n\t * If implementing, you MUST provide a JSX.Element <Trans> or <Fragment> tag (Trans tag preferred)\n\t */\n\tprotected rotationTableHeader?: JSX.Element\n\n\t/**\n\t * Implementing modules MAY provide a JSX element to appear above the RotationTable\n\t * If prepending multiple nodes, you MUST provide a JSX.Element <Fragment> tag\n\t */\n\tprotected prependMessages?: JSX.Element\n\n\t/**\n\t * Adds an evaluator to be run on the windows.\n\t * @param evaluator An evaluator to be run on the windows\n\t */\n\tprotected addEvaluator(evaluator: WindowEvaluator) {\n\t\tthis.evaluators.push(evaluator)\n\t}\n\n\t/**\n\t * Starts a new window if one is not already open.\n\t * @param timestamp The timestamp at which the new window starts.\n\t */\n\tprotected onWindowStart(timestamp: number) {\n\t\t// The event hook may already be set if multiple onWindowStart calls happen\n\t\t// before a call to onWindowEnd\n\t\tif (this.eventHook == null) {\n\t\t\tthis.eventHook = this.addEventHook(this.eventFilter, this.onWindowAction)\n\t\t}\n\t\tthis.history.getCurrentOrOpenNew(timestamp)\n\t}\n\t/**\n\t * Ends an existing window if one is open.\n\t * @param timestamp The timestamp at which the window ends.\n\t */\n\tprotected onWindowEnd(timestamp: number) {\n\t\t// The event hook may already be cleared if multiple onWindowEnd calls happen\n\t\t// before a call to onWindowStart\n\t\tif (this.eventHook != null) {\n\t\t\tthis.removeEventHook(this.eventHook)\n\t\t\tthis.eventHook = undefined\n\t\t}\n\t\tthis.history.closeCurrent(timestamp)\n\t}\n\t/**\n\t * Adds an action to the current window if one is open.\n\t * If no window is open, the event is ignored.\n\t * @param event The event to be added to the window.\n\t */\n\tprotected onWindowAction(event: Events['action']) {\n\t\tthis.history.doIfOpen(current => current.push(event))\n\t}\n\n\t/**\n\t * Adjusts the event filter to ignore certain actions.\n\t * Call this method if all casts of certain actions should be ignored\n\t * in a window.\n\t * If actions are only ignored in some conditions, this method is\n\t * not suitable, and you will need to register your own hook via setEventFilter.\n\t * @param actionsToIgnore The ids of the actions to ignore.\n\t */\n\tprotected ignoreActions(actionsToIgnore: number[]) {\n\t\tthis.eventFilter = filter<Event>()\n\t\t\t.source(this.parser.actor.id)\n\t\t\t.action(noneOf(actionsToIgnore))\n\t\t\t.type('action')\n\t}\n\t/**\n\t * Adjusts the event filter to only track certain actions.\n\t * Call this method if only some actions should be tracked in a window.\n\t * If other actions should be tracked in some conditions, this method is\n\t * not suitable, and you will need to register your own hook via\n\t * setEventFilter.\n\t * @param actionsToTrack The ids of the actions to track.\n\t */\n\tprotected trackOnlyActions(actionsToTrack: number[]) {\n\t\tthis.eventFilter = filter<Event>()\n\t\t\t.source(this.parser.actor.id)\n\t\t\t.action(oneOf(actionsToTrack))\n\t\t\t.type('action')\n\t}\n\n\t/**\n\t * Sets a custom event filter for the actions to capture during\n\t * a window.\n\t * @param filter The filter for actions to capture during a window\n\t */\n\tprotected setEventFilter(filter: EventFilterPredicate<Events['action']>) {\n\t\tthis.eventFilter = filter\n\t}\n\n\toverride initialise() {\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprivate onComplete() {\n\t\tthis.onWindowEnd(this.parser.pull.timestamp + this.parser.pull.duration)\n\n\t\tconst actionHistory = this.mapHistoryActions()\n\t\tthis.evaluators\n\t\t\t.forEach(ev => {\n\t\t\t\tconst suggestion = ev.suggest(actionHistory)\n\t\t\t\tif (suggestion != null) {\n\t\t\t\t\tthis.suggestions.add(suggestion)\n\t\t\t\t}\n\t\t\t})\n\t}\n\n\toverride output() {\n\t\tif (this.history.entries.length === 0) { return undefined }\n\n\t\tconst actionHistory = this.mapHistoryActions()\n\t\tconst evalColumns: EvaluationOutput[] = []\n\t\tfor (const ev of this.evaluators) {\n\t\t\tconst maybeColumns = ev.output(actionHistory)\n\t\t\tif (maybeColumns == null) { continue }\n\t\t\tfor (const column of ensureArray(maybeColumns)) {\n\t\t\t\tevalColumns.push(column)\n\t\t\t}\n\t\t}\n\n\t\tconst rotationTargets = evalColumns.filter(column => column.format === 'table').map(column => column.header)\n\t\tconst notesData = evalColumns.filter(column => column.format === 'notes').map(column => column.header)\n\t\tconst rotationData = this.history.entries\n\t\t\t.map((window, idx) => {\n\t\t\t\tconst targetsData: RotationTableTargetData = {}\n\t\t\t\tconst notesMap: RotationTableNotesMap = {}\n\t\t\t\tevalColumns.forEach(column => {\n\t\t\t\t\tif (typeof column.header.accessor !== 'string') { return }\n\t\t\t\t\tconst colName = column.header.accessor\n\t\t\t\t\tif (column.format === 'table') {\n\t\t\t\t\t\ttargetsData[colName] = column.rows[idx]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotesMap[colName] = column.rows[idx]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn {\n\t\t\t\t\tstart: window.start - this.parser.pull.timestamp,\n\t\t\t\t\tend: (window.end ?? window.start) - this.parser.pull.timestamp,\n\t\t\t\t\ttargetsData,\n\t\t\t\t\trotation: window.data.map(event => { return {action: event.action} }),\n\t\t\t\t\tnotesMap,\n\t\t\t\t}\n\t\t\t})\n\n\t\treturn <>\n\t\t\t{this.prependMessages}\n\t\t\t<RotationTable\n\t\t\t\ttargets={rotationTargets}\n\t\t\t\tdata={rotationData}\n\t\t\t\tnotes={notesData}\n\t\t\t\tonGoto={this.timeline.show}\n\t\t\t\theaderTitle={this.rotationTableHeader}\n\t\t\t/></>\n\t}\n\n\tprivate mapHistoryActions(): Array<HistoryEntry<EvaluatedAction[]>> {\n\t\treturn this.history.entries\n\t\t\t.map(entry => ({\n\t\t\t\tstart: entry.start,\n\t\t\t\tend: entry.end,\n\t\t\t\tdata: entry.data\n\t\t\t\t\t.map(ev => {\n\t\t\t\t\t\tconst action = this.data.getAction(ev.action)\n\t\t\t\t\t\tif (action == null) { return undefined }\n\t\t\t\t\t\treturn {...ev, action}\n\t\t\t\t\t})\n\t\t\t\t\t.filter(isDefined),\n\t\t\t}))\n\t}\n}\n","import {Status} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport _ from 'lodash'\nimport {TimestampHook, TimestampHookArguments} from 'parser/core/Dispatcher'\nimport {ensureArray} from 'utilities'\nimport {filter, oneOf} from '../../../filter'\nimport {EvaluatedAction} from '../EvaluatedAction'\nimport {HistoryEntry} from '../History'\nimport {ActionWindow} from './ActionWindow'\n\nconst SECONDS_TO_MS: number = 1000\n\n// In true XIV fashion, statuses tend to stick around for slightly longer than\n// their specified duration. It's pretty consistently about a second, so we're\n// adding that as a fudge.\nconst STATUS_DURATION_FUDGE = SECONDS_TO_MS\n\n/**\n * Tracks actions that occur while a buff status is active on the player.\n */\nexport abstract class BuffWindow extends ActionWindow {\n\n\t/**\n\t * The status that the buff window tracks.\n\t */\n\tabstract buffStatus: Status | Status[]\n\n\t/**\n\t * Determines if a window ended early due to the end of the pull.\n\t * @param window The window to check\n\t * @returns True if the window is shorter than the expected duration of the buff because of the end\n\t * of the pull; false otherwise.\n\t */\n\tprotected isRushedEndOfPullWindow(window: HistoryEntry<EvaluatedAction[]>) {\n\t\tconst expectedDuration = this.buffDuration ?? 0\n\t\tconst fightTimeRemaining = (this.parser.pull.timestamp + this.parser.pull.duration) - window.start\n\t\treturn expectedDuration >= fightTimeRemaining\n\t}\n\n\tprivate buffDuration?: number\n\tprivate durationHook?: TimestampHook\n\n\toverride initialise() {\n\t\tsuper.initialise()\n\n\t\t// buff windows are either active on the parser's actor\n\t\t// or on an enemy actor (trick attack)\n\t\t// enemies are not on the same team as the parser actor\n\t\tconst enemyTargets = this.parser.pull.actors\n\t\t\t.filter(actor => actor.team !== this.parser.actor.team)\n\t\t\t.map(actor => actor.id)\n\n\t\tconst targets = [this.parser.actor.id, ...enemyTargets]\n\t\tconst playerOwnedIds = this.parser.pull.actors\n\t\t\t.filter(actor => (actor.owner === this.parser.actor) || actor === this.parser.actor)\n\t\t\t.map(actor => actor.id)\n\n\t\tconst buffFilter = filter<Event>()\n\t\t\t.source(oneOf(playerOwnedIds))\n\t\t\t.target(oneOf(targets))\n\t\t\t.status(oneOf(ensureArray(this.buffStatus).map(s => s.id)))\n\n\t\tthis.addEventHook(buffFilter.type('statusApply'), this.onStatusApply)\n\t\tthis.addEventHook(buffFilter.type('statusRemove'), this.onStatusRemove)\n\t\tthis.buffDuration = _.max(ensureArray(this.buffStatus).map(s => s.duration))\n\t}\n\n\tprivate onStatusApply(event: Events['statusApply']) {\n\t\tthis.startWindowAndTimeout(event.timestamp)\n\t}\n\n\t/**\n\t * Start window at the timestamp provided and attach hook for closing the window\n\t * after the duration of the buff.\n\t *\n\t * Visible for RaidBuffWindow to reopen windows.\n\t * @param timestamp Time of buff application.\n\t */\n\tprotected startWindowAndTimeout(timestamp: number) {\n\t\tthis.onWindowStart(timestamp)\n\t\tif (this.buffDuration == null) { return }\n\t\tif (this.durationHook != null) {\n\t\t\tthis.removeTimestampHook(this.durationHook)\n\t\t}\n\t\tthis.durationHook = this.addTimestampHook(timestamp + this.buffDuration + STATUS_DURATION_FUDGE,\n\t\t\tthis.endWindowByTime)\n\t}\n\n\tprivate onStatusRemove(event: Events['statusRemove']) {\n\t\tthis.onWindowEnd(event.timestamp)\n\t\tif (this.durationHook != null) {\n\t\t\tthis.removeTimestampHook(this.durationHook)\n\t\t\tthis.durationHook = undefined\n\t\t}\n\t}\n\n\tprivate endWindowByTime(event: TimestampHookArguments) {\n\t\tthis.onWindowEnd(event.timestamp)\n\t\tthis.durationHook = undefined\n\t}\n}\n","module.exports = require('./head');\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nmodule.exports = head;\n","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    identity = require('./identity');\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n"],"names":["RotationTargetOutcome","RotationTable","this","props","targets","notes","data","onGoto","headerTitle","compact","unstackable","celled","collapsing","Trans","id","target","i","textAlign","header","note","entry","Row","start","actual","expected","isDefined","POSITIVE","NEGATIVE","NEUTRAL","React","targetAccessorResolver","accessor","targetsData","notesAccessorResolver","notesMap","TargetCell","targetComparator","undefined","defaultTargetComparator","targetOutcome","positive","negative","end","rotation","style","marginRight","formatDuration","secondPrecision","circular","size","icon","onClick","targetEntry","events","noteEntry","History","initializer","entries","dataInitializer","last","action","current","getCurrent","timestamp","closeCurrent","open","push","calculateExpectedGcdsForTime","defaultExpected","gcdEstimate","Math","min","ceil","ExpectedGcdCountEvaluator","opts","expectedGcds","globalCooldown","hasStacks","suggestionIcon","suggestionContent","suggestionWindowName","severityTiers","adjustCount","windows","missedGCDs","acc","window","calculateMissingGcdsForWindow","TieredSuggestion","content","tiers","value","why","format","rows","countGcdsInWindow","calculateExpectedGcdsForWindow","max","adjustedStart","getDuration","cast","onGcd","length","AllowedGcdsOnlyEvaluator","expectedGcdCount","allowedGcds","invalidGCDs","calculateBadGcdsForWindow","src","alt","height","countAllowedGcdsInWindow","ExpectedActionsEvaluator","expectedActions","adjustOutcome","missedActions","total","subTotal","countUsed","determineExpected","comparator","showName","actionHeader","name","expectedPerWindow","ExpectedActionGroupsEvaluator","expectedActionGroups","actionGroup","headerActions","actions","LimitedActionsEvaluator","badActions","PlayersBuffedEvaluator","affectedPlayers","expectedCount","affected","w","a","NotesEvaluator","_windows","generateNotes","RaidBuffWindow","raidBuffApplications","Array","partyMembers","parser","pull","actors","actor","playerControlled","playerOwnedIds","owner","statusFilter","filter","type","status","oneOf","ensureArray","buffStatus","s","addEventHook","source","onRaidBuffApply","noneOf","maybeReOpenPreviousWindow","addEvaluator","bind","event","buffWindow","windowEnd","history","endOfLastEntry","reopenLastEntry","startWindowAndTimeout","BuffWindow","ActionWindow","Data","Suggestions","Timeline","eventFilter","eventHook","evaluators","rotationTableHeader","prependMessages","evaluator","onWindowAction","getCurrentOrOpenNew","removeEventHook","doIfOpen","actionsToIgnore","actionsToTrack","onComplete","onWindowEnd","duration","actionHistory","mapHistoryActions","forEach","ev","suggestion","suggest","suggestions","add","evalColumns","maybeColumns","output","column","rotationTargets","notesData","rotationData","idx","colName","timeline","show","getAction","Analyser","dependency","buffDuration","durationHook","enemyTargets","team","buffFilter","onStatusApply","onStatusRemove","onWindowStart","removeTimestampHook","addTimestampHook","endWindowByTime","module","exports","array","baseExtremum","baseGt","identity"],"sourceRoot":""}