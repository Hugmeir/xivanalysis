{"version":3,"file":"assets/7969.795648e4.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/Combos.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Death.tsx"],"sourcesContent":["// If you can make it through this entire file without hitting semantic saturation of the word \"combo\", hats off to you. IT DOESN'T LOOK REAL ANYMORE.\n\nimport {t} from '@lingui/macro'\nimport {Plural, Trans} from '@lingui/react'\nimport Rotation from 'components/ui/Rotation'\nimport {ActionCombo} from 'data/ACTIONS/type'\nimport {Event, Events, FieldsMultiTargeted, SourceModifier} from 'event'\nimport _ from 'lodash'\nimport {dependency} from 'parser/core/Injectable'\nimport DISPLAY_ORDER from 'parser/core/modules/DISPLAY_ORDER'\nimport Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'\nimport {Timeline} from 'parser/core/modules/Timeline'\nimport React from 'react'\nimport {Button, Table} from 'semantic-ui-react'\nimport {Analyser} from '../Analyser'\nimport {filter} from '../filter'\nimport {Data} from './Data'\nimport {Death} from './Death'\nimport Downtime from './Downtime'\n\nconst DEFAULT_GCD = 2500\nconst COMBO_TIMEOUT = 30000\nconst CONTINUE_AFTER_DOWNTIME_GRACE = 1000\nconst ISSUE_TYPENAMES = {\n\tuncomboed: <Trans id=\"core.combos.issuetypenames.uncomboed\">Uncomboed</Trans>,\n\tcombobreak: <Trans id=\"core.combos.issuetypenames.combobreak\">Broken Combo</Trans>,\n\tfailedcombo: <Trans id=\"core.combos.issuetypenames.failed\">Missed or Invulnerable</Trans>,\n\ttimeout: <Trans id=\"core.combos.issuetypenames.timeout\">Expired</Trans>,\n}\n\ninterface EventCombo extends FieldsMultiTargeted {\n\taction: number\n}\n\ndeclare module 'event' {\n\tinterface EventTypeRepository {\n\t\tcombo: EventCombo\n\t}\n}\n\nexport interface ComboIssue {\n\ttype: keyof typeof ISSUE_TYPENAMES\n\tcontext: Array<Events['damage']>\n\tevent: Events['damage']\n}\n\nexport class Combos extends Analyser {\n\tstatic override handle = 'combos'\n\tstatic override title = t('core.combos.title')`Combo Issues`\n\tstatic override displayOrder = DISPLAY_ORDER.COMBOS\n\n\t// This should be redefined by subclassing modules; the default is the basic 'Attack' icon\n\tprotected suggestionIcon = 'https://xivapi.com/i/000000/000405.png'\n\n\t@dependency protected data!: Data\n\t@dependency private death!: Death\n\t@dependency private downtime!: Downtime\n\t@dependency protected suggestions!: Suggestions\n\t@dependency private timeline!: Timeline\n\n\tprivate lastGcdTime = this.parser.pull.timestamp\n\tprivate currentComboChain: Array<Events['damage']> = []\n\tprivate issues: ComboIssue[] = []\n\n\toverride initialise() {\n\t\tthis.addEventHook(filter<Event>().source(this.parser.actor.id).type('damage'), this.onCast)\n\t\tthis.addEventHook(filter<Event>().actor(this.parser.actor.id).type('death'), this.onDeath)\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprivate get lastComboEvent(): Events['damage'] | undefined {\n\t\treturn _.last(this.currentComboChain)\n\t}\n\n\tprivate get lastAction(): number | undefined {\n\t\tconst lastComboEvent = this.lastComboEvent\n\t\tif (!lastComboEvent || lastComboEvent.cause.type !== 'action') {\n\t\t\treturn undefined\n\t\t}\n\n\t\treturn lastComboEvent.cause.action\n\t}\n\n\tprivate get comboBreakers(): Array<Events['damage']> {\n\t\treturn this.issues\n\t\t\t.filter(issue => issue.type === 'combobreak')\n\t\t\t.map(issue => issue.event)\n\t}\n\n\tprivate get uncomboedGcds(): Array<Events['damage']> {\n\t\treturn this.issues\n\t\t\t.filter(issue => issue.type === 'uncomboed')\n\t\t\t.map(issue => issue.event)\n\t}\n\n\tprotected fabricateComboEvent(event: Events['damage']) {\n\t\tif (event.cause.type !== 'action') {\n\t\t\treturn\n\t\t}\n\t\tthis.parser.queueEvent({\n\t\t\ttype: 'combo',\n\t\t\ttimestamp: event.timestamp,\n\t\t\taction: event.cause.action,\n\t\t\tsource: event.source,\n\t\t\ttargets: event.targets,\n\t\t})\n\t}\n\n\tprivate recordBrokenCombo(event: Events['damage'], context: Array<Events['damage']>) {\n\t\tif (!this.isAllowableComboBreak(event, context)) {\n\t\t\tthis.issues.push({\n\t\t\t\ttype: 'combobreak',\n\t\t\t\tevent,\n\t\t\t\tcontext,\n\t\t\t})\n\t\t}\n\t\tthis.currentComboChain = []\n\t}\n\n\tprivate recordUncomboedGcd(event: Events['damage']) {\n\t\tthis.issues.push({\n\t\t\ttype: 'uncomboed',\n\t\t\tevent,\n\t\t\tcontext: [],\n\t\t})\n\t\tthis.currentComboChain = []\n\t}\n\n\tprivate recordFailedCombo(event: Events['damage'], context: Array<Events['damage']>) {\n\t\tthis.issues.push({\n\t\t\ttype: 'failedcombo',\n\t\t\tevent,\n\t\t\tcontext,\n\t\t})\n\t\tthis.currentComboChain = []\n\t}\n\n\tprivate recordExpiredCombo(event: Events['damage'], context: Array<Events['damage']>) {\n\t\tthis.issues.push({\n\t\t\ttype: 'timeout',\n\t\t\tevent,\n\t\t\tcontext,\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * @param combo\n\t * @param event\n\t * @return true if combo, false otherwise\n\t */\n\tprotected checkCombo(combo: ActionCombo, event: Events['damage']): boolean {\n\t\tconst lastAction = this.lastAction\n\t\t// Not in a combo\n\t\tif (lastAction == null) {\n\t\t\t// Combo starter, we good\n\t\t\tif (combo.start) {\n\t\t\t\tthis.fabricateComboEvent(event)\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// Combo action that isn't a starter, that's a paddlin'\n\t\t\tthis.recordUncomboedGcd(event)\n\t\t\treturn false\n\t\t}\n\n\t\tif (combo.start) {\n\t\t\t// Broken combo - starting a new combo while in a current combo\n\t\t\tthis.recordBrokenCombo(event, this.currentComboChain)\n\t\t\treturn true // Start a new combo\n\t\t}\n\n\t\tconst fromOptions = Array.isArray(combo.from) ? combo.from : [combo.from]\n\t\tif (fromOptions.includes(lastAction)) {\n\t\t\t// Combo continued correctly\n\t\t\tthis.fabricateComboEvent(event)\n\t\t\t// If it's a finisher, reset the combo\n\t\t\treturn !combo.end\n\t\t}\n\n\t\t// Action did not continue combo correctly and is not a new combo starter\n\t\tthis.recordBrokenCombo(event, this.currentComboChain)\n\t\treturn false\n\t}\n\n\tprivate onCast(event: Events['damage']) {\n\t\tif (event.cause.type !== 'action') {\n\t\t\treturn\n\t\t}\n\t\tconst action = this.data.getAction(event.cause.action)\n\n\t\tif (!action) {\n\t\t\treturn\n\t\t}\n\n\t\t// Only track GCDs that either progress or break combos so actions like Drill and Shadow Fang don't falsely extend the simulated combo timer\n\t\tif (action.onGcd && (action.combo != null || action.breaksCombo)) {\n\t\t\tconst comboExpiration = this.lastGcdTime + COMBO_TIMEOUT\n\t\t\tif (event.timestamp > comboExpiration && this.currentComboChain.length > 0) {\n\t\t\t\tif (!(this.downtime.getDowntime(comboExpiration - CONTINUE_AFTER_DOWNTIME_GRACE, comboExpiration) > 0)) {\n\t\t\t\t\t// Forgive the combo expiration if there was downtime within 1 second of the combo expiration (if downtime ends more than 1 second before combo expiration, record the timeout)\n\t\t\t\t\tthis.recordExpiredCombo(event, this.currentComboChain)\n\t\t\t\t}\n\t\t\t\t// If we've had enough downtime between GCDs to let the combo expire, reset the state so we don't count erroneous combo breaks\n\t\t\t\tthis.currentComboChain = []\n\t\t\t}\n\n\t\t\tthis.lastGcdTime = event.timestamp\n\t\t}\n\n\t\t// If it's a combo action, run it through the combo checking logic\n\t\tif (action.combo) {\n\t\t\tif (event.targets.every(t => t.sourceModifier === SourceModifier.MISS)) {\n\t\t\t\t// Misses break combo\n\t\t\t\tthis.recordFailedCombo(event, this.currentComboChain)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst continueCombo = this.checkCombo(action.combo, event)\n\t\t\tif (continueCombo) {\n\t\t\t\tthis.currentComboChain.push(event)\n\t\t\t} else {\n\t\t\t\tthis.currentComboChain = []\n\t\t\t}\n\t\t}\n\n\t\tif (action.breaksCombo && this.lastAction != null) {\n\t\t\t// Combo breaking action, that's a paddlin'\n\t\t\tthis.recordBrokenCombo(event, this.currentComboChain)\n\t\t}\n\t}\n\n\tprivate onDeath() {\n\t\t// Forgive combo breaks on death (the death ding is higher priority)\n\t\tthis.currentComboChain = []\n\t}\n\n\tprivate onComplete() {\n\t\tif (this.addJobSpecificSuggestions(this.comboBreakers, this.uncomboedGcds)) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: <Trans id=\"core.combos.content\">\n\t\t\t\t<p>Avoid breaking combos, as failing to complete combos costs you a significant amount of DPS and important secondary effects.</p>\n\t\t\t\t<p>Using a combo GCD at the wrong combo step, using non-combo GCDs while inside a combo, missing, or attacking a target that is invulnerable will cause your combo to break.</p>\n\t\t\t</Trans>,\n\t\t\ttiers: {\n\t\t\t\t1: SEVERITY.MINOR,\n\t\t\t\t2: SEVERITY.MEDIUM,\n\t\t\t\t4: SEVERITY.MAJOR,\n\t\t\t},\n\t\t\tvalue: this.issues.length,\n\t\t\twhy: <Plural\n\t\t\t\tid=\"core.combos.why\"\n\t\t\t\tvalue={this.issues.length}\n\t\t\t\tone=\"You misused # combo action.\"\n\t\t\t\tother=\"You misused # combo actions.\"\n\t\t\t/>,\n\t\t}))\n\t}\n\n\t/**\n\t * Jobs MAY override this to add additional suggestions beyond the default\n\t * @param comboBreakers An array of combos that were broken (not completed with a combo finisher)\n\t * @param uncomboedGcds An array of combo actions that were used outside of a combo (events that combo from other events, but were used when no combo chain was active)\n\t * @returns true to prevent adding the default suggestion, or false to include the default suggestions\n\t */\n\tprotected addJobSpecificSuggestions(_comboBreakers: Array<Events['damage']>, _uncomboedGcds: Array<Events['damage']>): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Jobs MAY override this to indicate whether this broken combo is allowed.\n\t * Return true to indicate an allowable combo break, which will result in this break not being recorded and the current combo will be cleared with no other side effects.\n\t * Return false to record the combo break and display it to the user\n\t * @param event The event that caused the combo break\n\t * @param context The active combo chain that is being broken\n\t * @returns true if this combo break should not be recorded\n\t */\n\tprotected isAllowableComboBreak(_event: Events['damage'], _context: Array<Events['damage']>): boolean {\n\t\treturn false\n\t}\n\n\t// Helper needed to make this.timeline.show behave, remove when timeline is a Sith and deals in absolutes\n\tprivate relativeTimestamp(timestamp: number) {\n\t\treturn timestamp - this.parser.pull.timestamp\n\t}\n\n\toverride output(): React.ReactNode {\n\t\tif (this.issues.length <= 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst data = this.issues.sort((a, b) => a.event.timestamp - b.event.timestamp)\n\n\t\treturn <Table compact unstackable celled textAlign=\"center\">\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.combos-table.header.starttime\">Start Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.combos-table.header.comboactions\">Combo Actions</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.combos-table.header.brokentime\">Broken Time</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.combos-table.header.combobreaker\">Combo Breaker</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell collapsing>\n\t\t\t\t\t\t<strong><Trans id=\"core.ui.combos-table.header.reason\">Reason</Trans></strong>\n\t\t\t\t\t</Table.HeaderCell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{\n\t\t\t\t\tdata.map(issue => {\n\t\t\t\t\t\tconst completeContext = [...(issue.context || []), issue.event]\n\n\t\t\t\t\t\tconst startEvent = completeContext[0]\n\t\t\t\t\t\tconst brokenTime = issue.type !== 'timeout' ? completeContext[completeContext.length-1].timestamp : startEvent.timestamp + COMBO_TIMEOUT\n\n\t\t\t\t\t\treturn <Table.Row key={startEvent.timestamp}>\n\t\t\t\t\t\t\t<Table.Cell style={{whiteSpace: 'nowrap'}}>\n\t\t\t\t\t\t\t\t{issue.context.length > 0 &&\n\t\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t\t<span>{this.parser.formatEpochTimestamp(startEvent.timestamp, 0)}</span>\n\t\t\t\t\t\t\t\t\t\t<Button style={{marginLeft: 5}}\n\t\t\t\t\t\t\t\t\t\t\tcircular\n\t\t\t\t\t\t\t\t\t\t\tcompact\n\t\t\t\t\t\t\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\t\t\t\t\t\t\ticon=\"time\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.timeline.show(this.relativeTimestamp(startEvent.timestamp), this.relativeTimestamp(brokenTime + DEFAULT_GCD))}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</>}\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t<Rotation events={issue.context} />\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell style={{whiteSpace: 'nowrap'}}>\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t<span>{this.parser.formatEpochTimestamp(brokenTime, 0)}</span>\n\t\t\t\t\t\t\t\t\t{issue.context.length === 0 &&\n\t\t\t\t\t\t\t\t\t<Button style={{marginLeft: 5}}\n\t\t\t\t\t\t\t\t\t\tcircular\n\t\t\t\t\t\t\t\t\t\tcompact\n\t\t\t\t\t\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\t\t\t\t\t\ticon=\"time\"\n\t\t\t\t\t\t\t\t\t\tonClick={() => this.timeline.show(this.relativeTimestamp(brokenTime - DEFAULT_GCD), this.relativeTimestamp(brokenTime + DEFAULT_GCD))}\n\t\t\t\t\t\t\t\t\t/>}\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t{issue.type !== 'timeout' && <Rotation events={[issue.event]}/>}\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t\t<span style={{whiteSpace: 'nowrap'}}>{ISSUE_TYPENAMES[issue.type]}</span>\n\t\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t</Table.Row>\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t</Table.Body>\n\t\t</Table>\n\t}\n}\n","import {Plural, Trans} from '@lingui/react'\nimport {Event, Events, FieldsBase, Resource} from 'event'\nimport React from 'react'\nimport {Actor} from 'report'\nimport {Analyser} from '../Analyser'\nimport {EventHook} from '../Dispatcher'\nimport {filter} from '../filter'\nimport {dependency} from '../Injectable'\nimport {Data} from './Data'\nimport Suggestions, {SEVERITY, Suggestion} from './Suggestions'\nimport {SimpleItem, Timeline} from './Timeline'\n\ninterface EventDeath extends FieldsBase {\n\t/** Actor that died. */\n\tactor: Actor['id'],\n\t/**\n\t * Whether or not the death should be counted.\n\t * @see `Death#shouldCountDeath`\n\t */\n\tcounted: boolean\n}\n\ninterface EventRaise extends FieldsBase {\n\t/** Actor that was raised. */\n\tactor: Actor['id']\n}\n\ndeclare module 'event' {\n\tinterface EventTypeRepository {\n\t\tdeath: EventDeath\n\t\traise: EventRaise\n\t}\n}\n\ninterface ActorInfo {\n\ttimestampDeath?: Event['timestamp']\n\ttimestampTranscendent?: Event['timestamp']\n\tcount: number\n\tduration: number\n\traiseHook?: EventHook<Events['actorUpdate']>\n}\n\nexport class Death extends Analyser {\n\tstatic override handle = 'death'\n\tstatic override debug = true\n\n\t@dependency private data!: Data\n\t@dependency private suggestions!: Suggestions\n\t@dependency private timeline!: Timeline\n\n\t/** Accumulated time the parsed actor has spent dead over the course of the fight. */\n\tget deadTime() {\n\t\treturn this.getDuration(this.parser.actor.id)\n\t}\n\n\tprivate info = new Map<Actor['id'], ActorInfo>()\n\n\tgetCount(actorId: Actor['id']) {\n\t\treturn this.getActorInfo(actorId).count\n\t}\n\n\tgetDuration(actorId: Actor['id']) {\n\t\tconst actorInfo = this.getActorInfo(actorId)\n\t\tconst timestamp = this.parser.currentEpochTimestamp\n\t\tconst currentDeadTime = timestamp - (actorInfo.timestampDeath ?? timestamp)\n\t\treturn actorInfo.duration + currentDeadTime\n\t}\n\n\toverride initialise() {\n\t\t// An actor hitting 0 HP is a sign of a death.\n\t\tthis.addEventHook({\n\t\t\ttype: 'actorUpdate',\n\t\t\thp: {current: 0},\n\t\t}, this.onDeath)\n\n\t\t// An actor gaining transcendent is a sign of a raise.\n\t\tthis.addEventHook({\n\t\t\ttype: 'statusApply',\n\t\t\tstatus: this.data.statuses.TRANSCENDENT.id,\n\t\t}, this.onTranscendentApply)\n\n\t\t// Any possible death events before transcendent falls off are flakes\n\t\tthis.addEventHook({\n\t\t\ttype: 'statusRemove',\n\t\t\tstatus: this.data.statuses.TRANSCENDENT.id,\n\t\t}, this.onTranscendentRemove)\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprivate getActorInfo(actorId: Actor['id']): ActorInfo {\n\t\tlet actorInfo = this.info.get(actorId)\n\t\tif (actorInfo == null) {\n\t\t\tactorInfo = {count: 0, duration: 0}\n\t\t\tthis.info.set(actorId, actorInfo)\n\t\t}\n\t\treturn actorInfo\n\t}\n\n\tprivate onDeath(event: Events['actorUpdate']) {\n\t\tconst actorInfo = this.getActorInfo(event.actor)\n\n\t\t// If we already have a death being tracked, or the player is still\n\t\t// transcendent, it's likely duplicate info, noop\n\t\tif (\n\t\t\tactorInfo.timestampDeath != null\n\t\t\t|| actorInfo.timestampTranscendent != null\n\t\t) { return }\n\n\t\tconst counted = this.shouldCountDeath(event)\n\n\t\t// Queue an event for the death\n\t\tthis.parser.queueEvent({\n\t\t\ttype: 'death',\n\t\t\ttimestamp: event.timestamp,\n\t\t\tactor: event.actor,\n\t\t\tcounted,\n\t\t})\n\n\t\t// If we're not counting, can stop here\n\t\tif (!counted) { return }\n\n\t\tactorInfo.timestampDeath = event.timestamp\n\t\tactorInfo.count++\n\n\t\t// Keep an eye out for the actor gaining health post-death - it signals that it has resurrected in some\n\t\t// manner that bypassed the transcendent check. Transcendent itself is applied before any HP gain, so\n\t\t// player actors will likely not trigger this hook.\n\t\tactorInfo.raiseHook = this.addEventHook(\n\t\t\tfilter<Event>()\n\t\t\t\t.type('actorUpdate')\n\t\t\t\t.actor(event.actor)\n\t\t\t\t.hp(filter<Resource>()\n\t\t\t\t\t.current((value): value is number => value > 0)),\n\t\t\tevent => this.onRaise(event.actor, event.timestamp),\n\t\t)\n\t}\n\n\t/**\n\t * Determine if an event presumed to represent an actor's death should\n\t * be counted as such. Override and provide custom logic for cases where\n\t * a death is forced by fights or otherwise cannot be avoided.\n\t * @param _event ActorUpdate event marking the actor's death.\n\t */\n\tprotected shouldCountDeath(_event: Events['actorUpdate']) {\n\t\treturn true\n\t}\n\n\tprivate onTranscendentApply(event: Events['statusApply']) {\n\t\tconst actorInfo = this.getActorInfo(event.target)\n\t\tactorInfo.timestampTranscendent = event.timestamp\n\t\tthis.onRaise(event.target, event.timestamp)\n\t}\n\n\tprivate onTranscendentRemove(event: Events['statusRemove']) {\n\t\tconst actorInfo = this.getActorInfo(event.target)\n\t\tactorInfo.timestampTranscendent = undefined\n\t}\n\n\tprivate onRaise(actorId: Actor['id'], timestamp: Event['timestamp']) {\n\t\tconst actorInfo = this.getActorInfo(actorId)\n\n\t\t// If there's no current death, likely duplicate info, noop\n\t\tif (actorInfo.timestampDeath == null) { return }\n\n\t\t// We only show the parsed player's deaths on the timeline itself\n\t\tif (actorId === this.parser.actor.id) {\n\t\t\tthis.addDeathToTimeline(actorInfo.timestampDeath, timestamp)\n\t\t}\n\n\t\tactorInfo.duration += timestamp - actorInfo.timestampDeath\n\t\tactorInfo.timestampDeath = undefined\n\n\t\tif (actorInfo.raiseHook != null) {\n\t\t\tthis.removeEventHook(actorInfo.raiseHook)\n\t\t\tactorInfo.raiseHook = undefined\n\t\t}\n\n\t\t// Queue the raise notification.\n\t\tthis.parser.queueEvent({\n\t\t\ttype: 'raise',\n\t\t\ttimestamp,\n\t\t\tactor: actorId,\n\t\t})\n\t}\n\n\tprivate onComplete(event: Events['complete']) {\n\t\tfor (const [actorId, actorInfo] of this.info) {\n\t\t\t// If the actor was dead on completion, and the pull was a wipe, refund the\n\t\t\t// death. It's pretty meaningless to complain about the wipe itself.\n\t\t\tif (\n\t\t\t\t(this.parser.pull.progress ?? 0) < 100\n\t\t\t\t&& actorInfo.timestampDeath != null\n\t\t\t) {\n\t\t\t\tactorInfo.count = Math.max(actorInfo.count - 1, 0)\n\t\t\t}\n\n\t\t\t// Run raise cleanup in case the actor was dead on completion\n\t\t\tthis.onRaise(actorId, event.timestamp)\n\t\t}\n\n\t\tconst playerInfo = this.getActorInfo(this.parser.actor.id)\n\t\tif (playerInfo.count === 0) { return }\n\n\t\t// Deaths are pretty morbid\n\t\tthis.suggestions.add(new Suggestion({\n\t\t\ticon: this.data.actions.RAISE.icon,\n\t\t\tcontent: <Trans id=\"core.deaths.content\">\n\t\t\t\tDon't die. Between downtime, lost gauge resources, and resurrection debuffs, dying is absolutely <em>crippling</em> to damage output.\n\t\t\t</Trans>,\n\t\t\tseverity: SEVERITY.MORBID,\n\t\t\twhy: <Plural\n\t\t\t\tid=\"core.deaths.why\"\n\t\t\t\tvalue={playerInfo.count}\n\t\t\t\t_1=\"# death\"\n\t\t\t\tother=\"# deaths\"\n\t\t\t/>,\n\t\t}))\n\t}\n\n\tprivate addDeathToTimeline(start: number, end: number) {\n\t\tthis.timeline.addItem(new SimpleItem({\n\t\t\tstart: start - this.parser.pull.timestamp,\n\t\t\tend: end - this.parser.pull.timestamp,\n\t\t\t// TODO: Improve?\n\t\t\tcontent: <div style={{\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%',\n\t\t\t\tbackgroundColor: '#ce909085',\n\t\t\t}}/>,\n\t\t}))\n\t}\n}\n"],"names":["DEFAULT_GCD","ISSUE_TYPENAMES","uncomboed","Trans","id","combobreak","failedcombo","timeout","Combos","Data","Death","Downtime","Suggestions","Timeline","suggestionIcon","lastGcdTime","parser","pull","timestamp","currentComboChain","issues","this","addEventHook","filter","source","actor","type","onCast","onDeath","onComplete","lastComboEvent","cause","action","issue","event","queueEvent","targets","context","isAllowableComboBreak","push","combo","lastAction","start","fabricateComboEvent","recordUncomboedGcd","recordBrokenCombo","fromOptions","Array","isArray","from","end","data","getAction","onGcd","breaksCombo","comboExpiration","length","downtime","getDowntime","recordExpiredCombo","every","t","sourceModifier","SourceModifier","recordFailedCombo","checkCombo","addJobSpecificSuggestions","comboBreakers","uncomboedGcds","suggestions","add","TieredSuggestion","icon","content","tiers","SEVERITY","value","why","_comboBreakers","_uncomboedGcds","_event","_context","a","b","compact","unstackable","celled","textAlign","collapsing","completeContext","startEvent","brokenTime","style","whiteSpace","formatEpochTimestamp","marginLeft","circular","size","onClick","timeline","show","relativeTimestamp","events","Analyser","handle","title","displayOrder","DISPLAY_ORDER","dependency","death","info","getDuration","actorId","getActorInfo","count","actorInfo","currentEpochTimestamp","currentDeadTime","timestampDeath","duration","hp","current","status","statuses","TRANSCENDENT","onTranscendentApply","onTranscendentRemove","get","set","timestampTranscendent","counted","shouldCountDeath","raiseHook","onRaise","target","undefined","addDeathToTimeline","removeEventHook","progress","Math","max","playerInfo","Suggestion","actions","RAISE","severity","addItem","SimpleItem","width","height","backgroundColor","debug"],"sourceRoot":""}