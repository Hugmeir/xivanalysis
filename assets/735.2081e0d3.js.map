{"version":3,"file":"assets/735.2081e0d3.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.module.css?2f05","webpack://@xivanalysis/client/./src/parser/core/modules/Defensives.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/DoTs.ts","webpack://@xivanalysis/client/./src/parser/core/modules/Overheal.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Statuses.ts"],"sourcesContent":["import {Trans} from '@lingui/react'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {Analyser} from 'parser/core/Analyser'\nimport {dependency} from 'parser/core/Injectable'\nimport CastTime from 'parser/core/modules/CastTime'\nimport {ChargeHistoryEntry, CooldownEndReason, CooldownGroup, CooldownHistoryEntry, Cooldowns, SelectionSpecifier} from 'parser/core/modules/Cooldowns'\nimport {Data} from 'parser/core/modules/Data'\nimport {ActionItem, BaseItem, ContainerRow, SimpleItem, Timeline} from 'parser/core/modules/Timeline'\nimport React, {ReactNode} from 'react'\nimport {Icon} from 'semantic-ui-react'\nimport {ensureArray, isDefined} from 'utilities'\nimport styles from './ActionTimeline.module.css'\n\nconst ANIMATION_LOCK = 100\n\n// We're excluding the Action interface as it's unessecary for this config format, and complicates the discrimination later.\ntype RowSpecifierEntry = Exclude<SelectionSpecifier, Action>\n\n/**\n * One or more actions, action keys, or cooldown group IDs. The special-case\n * value \"GCD\" is available for selection of the GCD cooldown group.\n */\nexport type RowSpecifier = RowSpecifierEntry | RowSpecifierEntry[]\n\n/** Advanced configuration options for a row. */\nexport interface ActionRowConfig {\n\t/** Specifier(s) for items that should be displayed in this row. */\n\tcontent: RowSpecifier\n\t/** Label to display for the row. */\n\tlabel?: ReactNode\n\t/** Order of the row within the timeline. */\n\torder?: number\n}\n\n/** Configuration for a single row. */\nexport type ActionRow = RowSpecifier | ActionRowConfig\n\n// Internal row config used within the module\ntype InternalRowConfig =\n\t& Omit<ActionRowConfig, 'content'>\n\t& {content: readonly SelectionSpecifier[]}\n\nenum ItemDepth {\n\tCHARGE_GAIN = 0,\n\tACTION = 1,\n}\n\nexport class ActionTimeline extends Analyser {\n\tstatic override handle = 'actionTimeline'\n\tstatic override debug = false\n\n\t/**\n\t * Configuration for the rows generated by this module. Any cooldown groups\n\t * not represented in this configuration will be added to automatically\n\t * generated rows in order of use.\n\t */\n\tstatic rows: ActionRow[] = [\n\t\t{content: 'GCD', order: -97},\n\t]\n\n\t@dependency private castTime!: CastTime\n\t@dependency private cooldowns!: Cooldowns\n\t@dependency private data!: Data\n\t@dependency private timeline!: Timeline\n\n\tprivate resolvedRows: InternalRowConfig[] = []\n\tprivate groupRows = new Map<CooldownGroup, ContainerRow>()\n\n\t/** Retrieve the timeline row representing the specified action. */\n\tgetRow(action: ActionKey | Action) {\n\t\treturn this.addRow({content: [action]})\n\t}\n\n\toverride initialise() {\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of (this.constructor as typeof ActionTimeline).rows) {\n\t\t\tconst resolvedConfig = this.resolveConfig(config)\n\t\t\tthis.resolvedRows.push(resolvedConfig)\n\t\t\tthis.addRow(resolvedConfig)\n\t\t}\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprivate onComplete() {\n\t\t// Track the groups with configured rows so backfill doesn't duplicate\n\t\tconst populatedGroups = new Set<number>()\n\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of this.resolvedRows) {\n\t\t\tconst row = this.addRow(config)\n\t\t\tthis.populateRow(row, config)\n\t\t\tconfig.content.forEach(specifier =>\n\t\t\t\tthis.cooldowns.groups(specifier).forEach(group => populatedGroups.add(group))\n\t\t\t)\n\t\t}\n\n\t\t// Figure out what groups have not been explicitly configured and build rows for them\n\t\tthis.cooldowns.allGroups()\n\t\t\t.filter(group => !populatedGroups.has(group))\n\t\t\t.forEach(group => {\n\t\t\t\tconst config = {content: [group]}\n\t\t\t\tconst row = this.addRow(config)\n\t\t\t\tthis.populateRow(row, config)\n\t\t\t})\n\t}\n\n\tprivate resolveConfig(config: ActionRow): InternalRowConfig {\n\t\t// Standardise the simple config into the main config shape\n\t\tlet finalConfig = config\n\t\tif (typeof finalConfig !== 'object' || Array.isArray(finalConfig)) {\n\t\t\tfinalConfig = {content: finalConfig}\n\t\t}\n\t\treturn {\n\t\t\t...finalConfig,\n\t\t\tcontent: ensureArray(finalConfig.content),\n\t\t}\n\t}\n\n\tprivate addRow(config: InternalRowConfig) {\n\t\t// If there's already a row for one of the specifiers, use it\n\t\tconst groups = config.content.flatMap(specifier => this.cooldowns.groups(specifier))\n\t\tconst existingRow = groups\n\t\t\t.map(group => this.groupRows.get(group))\n\t\t\t.find(isDefined)\n\t\tif (existingRow != null) {\n\t\t\treturn existingRow\n\t\t}\n\n\t\t// Using an IIFE because pattern matching isn't in the spec yet\n\t\tconst firstContent = config.content[0]\n\t\tconst label = (() => {\n\t\t\tif (config.label != null) { return config.label }\n\t\t\tif (firstContent === 'GCD')  { return <Trans id=\"core.action-timeline.label.gcd\">GCD</Trans> }\n\t\t\tif (typeof firstContent === 'string') { return this.data.actions[firstContent].name }\n\t\t\tif (typeof firstContent === 'number') { return this.cooldowns.cooldownHistory(firstContent)[0]?.action.name }\n\t\t\treturn firstContent.name\n\t\t})()\n\n\t\t// Build the row and save it to the groups for this config\n\t\t// TODO: collision handling?\n\t\tconst row = this.timeline.addRow(new ContainerRow({\n\t\t\tlabel,\n\t\t\torder: config.order,\n\t\t\tcollapse: true,\n\t\t}))\n\t\tgroups.forEach(group => this.groupRows.set(group, row))\n\n\t\treturn row\n\t}\n\n\tprivate populateRow(row: ContainerRow, {content}: InternalRowConfig) {\n\t\t// Add all the items\n\t\tthis.addCooldownItems(row, content.flatMap(specifier => this.cooldowns.cooldownHistory(specifier)))\n\t\tthis.addChargeItems(row, content.flatMap(specifier => this.cooldowns.chargeHistory(specifier)))\n\t}\n\n\tprivate addCooldownItems(row: ContainerRow, history: CooldownHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst duration = this.getCooldownDuration(entry)\n\n\t\t\t// TODO: with the adjusted cast time we might get some overlaps, should we try to avoid that?]\n\t\t\t// TODO: Add interrupt visuals. CD2 only records interrupts within the bounds of a cooldown, so we'll need to track it in some manner for long-cast actions.\n\t\t\tconst start = entry.start - this.parser.pull.timestamp\n\t\t\tconst end = start + duration\n\t\t\trow.addItem(new SimpleItem({\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tcontent: <div className={styles.cooldown}/>,\n\t\t\t}))\n\t\t}\n\t}\n\n\tprivate addChargeItems(row: ContainerRow, history: ChargeHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst item = entry.delta < 0\n\t\t\t\t? new ActionItem({\n\t\t\t\t\tdepth: ItemDepth.ACTION,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t\taction: entry.action,\n\t\t\t\t})\n\t\t\t\t: new ChargeGainItem({\n\t\t\t\t\tdepth: ItemDepth.CHARGE_GAIN,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t})\n\t\t\trow.addItem(item)\n\t\t}\n\t}\n\n\tprivate getCooldownDuration(entry: CooldownHistoryEntry) {\n\t\tlet duration = entry.end - entry.start\n\n\t\t// If the cooldown expired naturally, it _may_ have a cast time greater than its cooldown.\n\t\tif (entry.endReason === CooldownEndReason.EXPIRED) {\n\t\t\tconst castTime = this.castTime.forAction(entry.action.id, entry.start) ?? 0\n\n\t\t\t// We add the animation lock constant to the cast time to mimic the game's\n\t\t\t// behaviour - also sometimes known as \"caster tax\".\n\t\t\tduration = Math.max(duration, castTime + ANIMATION_LOCK)\n\t\t}\n\n\t\treturn duration\n\t}\n}\n\nclass ChargeGainItem extends BaseItem {\n\tContent = () => (\n\t\t<div className={styles.chargeGain}>\n\t\t\t<Icon name=\"angle double up\" className={styles.icon}/>\n\t\t</div>\n\t)\n}\n","// extracted by mini-css-extract-plugin\nexport default {\"backgroundColour\":\"rgba(213, 221, 246, .4)\",\"chargeColor\":\"color(rgba(213, 221, 246, .4) a(100%) l(-20%))\",\"cooldown\":\"ActionTimeline-module_cooldown__3u1x3\",\"chargeGain\":\"ActionTimeline-module_chargeGain__3-Of9\",\"icon\":\"ActionTimeline-module_icon__8OvsF\"};","import {t} from '@lingui/macro'\nimport {Plural, Trans} from '@lingui/react'\nimport {ActionLink} from 'components/ui/DbLink'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {JOBS, RoleKey} from 'data/JOBS'\nimport {Analyser} from 'parser/core/Analyser'\nimport {dependency} from 'parser/core/Injectable'\nimport {CooldownDowntime} from 'parser/core/modules/CooldownDowntime'\nimport {Data} from 'parser/core/modules/Data'\nimport React, {Fragment, ReactNode} from 'react'\nimport {Accordion, Button, Icon, Message, Table} from 'semantic-ui-react'\nimport {CooldownEndReason, CooldownHistoryEntry, Cooldowns} from './Cooldowns'\nimport DISPLAY_ORDER from './DISPLAY_ORDER'\nimport {Timeline} from './Timeline'\n\nconst DEFENSIVE_ROLE_ACTIONS: Map<RoleKey, ActionKey[]> = new Map<RoleKey, ActionKey[]>([\n\t['TANK', ['RAMPART', 'REPRISAL']],\n\t['MELEE', ['FEINT', 'BLOODBATH', 'SECOND_WIND']],\n\t['PHYSICAL_RANGED', ['SECOND_WIND']],\n\t['MAGICAL_RANGED', ['ADDLE']],\n\t['HEALER', []],\n])\n\nexport class Defensives extends Analyser {\n\tstatic override handle = 'defensives'\n\tstatic override title = t('core.defensives.title')`Defensives`\n\tstatic override displayOrder = DISPLAY_ORDER.DEFENSIVES\n\n\t@dependency protected cooldowns!:Cooldowns\n\t@dependency protected cooldownDowntime!: CooldownDowntime\n\t@dependency protected data!: Data\n\t@dependency private timeline!: Timeline\n\n\t/**\n\t * Implementing modules should provide a list of job-specific defensive actions to track\n\t */\n\tprotected trackedDefensives: Action[] = []\n\t/**\n\t * Implementing modules may override the main header message text\n\t */\n\tprotected headerContent: ReactNode = <Trans id=\"core.defensives.header.content\">\n\t\tUsing your mitigation and healing cooldowns can help you survive mistakes, or relieve some stress on the healers and let them deal more damage.<br/>\n\t\tWhile you shouldn't use them at the expense of your rotation or buff alignment, you should try to find helpful times to use them.\n\t</Trans>\n\n\toverride initialise() {\n\t\tconst roleDefensives = DEFENSIVE_ROLE_ACTIONS.get(JOBS[this.parser.actor.job].role)?.map(key => this.data.actions[key]) ?? []\n\t\troleDefensives.forEach(roleAction => {\n\t\t\tif (!this.trackedDefensives.find(action => roleAction.id === action.id)) {\n\t\t\t\tthis.trackedDefensives.push(roleAction)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getUsageCount(defensive: Action): number {\n\t\treturn this.getUses(defensive).length\n\t}\n\n\tprivate getUses(defensive: Action): CooldownHistoryEntry[] {\n\t\treturn this.cooldowns.cooldownHistory(defensive).filter((entry) => entry.endReason !== CooldownEndReason.INTERRUPTED)\n\t}\n\n\tprivate getMaxUses(defensive: Action): number {\n\t\tconst totalAdditionalUses = this.getUses(defensive).reduce((acc, usage) => acc + this.getAdditionalUsageData(defensive, usage.start).chargesBeforeNextUse, this.getAdditionalUsageData(defensive).chargesBeforeNextUse)\n\t\treturn this.getUsageCount(defensive) + totalAdditionalUses\n\t}\n\n\toverride output() {\n\t\tif (this.trackedDefensives.length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\treturn <Fragment>\n\t\t\t<Message icon>\n\t\t\t\t<Icon name=\"info\" />\n\t\t\t\t<Message.Content>\n\t\t\t\t\t{this.headerContent}\n\t\t\t\t\t<br/><br/>\n\t\t\t\t\t<Trans id=\"core.defensives.header.sub-content\">\n\t\t\t\t\t\tThe below tables will show you where you can gain additional uses of these cooldowns, without interfering with your existing ones.\n\t\t\t\t\t</Trans>\n\t\t\t\t</Message.Content>\n\t\t\t</Message>\n\t\t\t<Accordion\n\t\t\t\texclusive={false}\n\t\t\t\tstyled\n\t\t\t\tfluid\n\t\t\t\tpanels={\n\t\t\t\t\tthis.trackedDefensives.map((defensive, index) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tkey: defensive.id,\n\t\t\t\t\t\t\ttitle: {\n\t\t\t\t\t\t\t\tcontent: <><ActionLink key={index} {...defensive} /> - {this.getUsageCount(defensive)} / {this.getMaxUses(defensive)}</>,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\tcontent: <Table compact unstackable celled>\n\t\t\t\t\t\t\t\t\t<Table.Body>\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.tryGetAdditionalUseRow(defensive)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.getUses(defensive).map((entry) => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.getUsageRow(entry, defensive)\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t</Table.Body>\n\t\t\t\t\t\t\t\t</Table>,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t/>\n\t\t</Fragment>\n\t}\n\n\tprivate getUsageRow(entry: CooldownHistoryEntry, defensive: Action): ReactNode {\n\t\treturn <>\n\t\t\t<Table.Row key={entry.start}>\n\t\t\t\t<Table.Cell>\n\t\t\t\t\t<Trans id=\"core.defensives.table.usage-row.text\">Used at <Button\n\t\t\t\t\t\tcircular\n\t\t\t\t\t\tcompact\n\t\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\t\ticon=\"time\"onClick={() => this.timeline.show(entry.start - this.parser.pull.timestamp, entry.end - this.parser.pull.timestamp)}>\n\t\t\t\t\t</Button> {this.parser.formatEpochTimestamp(entry.start)}\n\t\t\t\t\t</Trans>\n\t\t\t\t</Table.Cell>\n\t\t\t</Table.Row>\n\t\t\t{\n\t\t\t\tthis.tryGetAdditionalUseRow(defensive, entry.start)\n\t\t\t}\n\t\t</>\n\t}\n\n\tprivate getAdditionalUsageData(defensive: Action, timestamp: number = this.parser.pull.timestamp): {chargesBeforeNextUse: number, availableTimestamp: number, useByTimestamp: number} {\n\t\tlet availableTimestamp: number, currentCharges\n\n\t\tif (timestamp === this.parser.pull.timestamp) {\n\t\t\tavailableTimestamp = this.parser.pull.timestamp\n\t\t\tcurrentCharges = defensive.charges || 1\n\t\t} else {\n\t\t\tconst chargesAvailableEvent = this.cooldowns.chargeHistory(defensive).find(charges => charges.timestamp >= timestamp && charges.current > 0)\n\t\t\tavailableTimestamp = chargesAvailableEvent?.timestamp || (this.parser.pull.duration + this.parser.pull.timestamp)\n\t\t\tcurrentCharges = chargesAvailableEvent?.current || 0\n\t\t}\n\n\t\tconst cooldown = defensive.cooldown || this.parser.pull.duration\n\t\tconst nextEntry = this.getUses(defensive).find(historyEntry => historyEntry.start > timestamp)\n\t\tconst useByTimestamp = nextEntry != null ? (nextEntry.start - cooldown) : (this.parser.pull.timestamp + this.parser.pull.duration)\n\n\t\tif (useByTimestamp <= availableTimestamp) {\n\t\t\treturn {chargesBeforeNextUse: 0, availableTimestamp, useByTimestamp}\n\t\t}\n\n\t\treturn {chargesBeforeNextUse: currentCharges + Math.floor((useByTimestamp - availableTimestamp) / cooldown), availableTimestamp, useByTimestamp}\n\t}\n\n\tprivate tryGetAdditionalUseRow(defensive: Action, timestamp: number = this.parser.pull.timestamp): ReactNode {\n\t\tconst {chargesBeforeNextUse, availableTimestamp, useByTimestamp} = this.getAdditionalUsageData(defensive, timestamp)\n\n\t\tif (chargesBeforeNextUse === 0) {\n\t\t\treturn <></>\n\t\t}\n\n\t\treturn <Table.Row>\n\t\t\t<Table.Cell>\n\t\t\t\t<Trans id=\"core.defensives.table.extra-usage-row.text\"><Plural value={chargesBeforeNextUse} one=\"1 extra use\" other=\"# extra uses\"/> available between <Button\n\t\t\t\t\tcircular\n\t\t\t\t\tcompact\n\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\ticon=\"time\"onClick={() => this.timeline.show(availableTimestamp - this.parser.pull.timestamp, useByTimestamp - this.parser.pull.timestamp)}>\n\t\t\t\t</Button> {this.parser.formatEpochTimestamp(availableTimestamp)} and {this.parser.formatEpochTimestamp(useByTimestamp)}\n\t\t\t\t</Trans>\n\t\t\t</Table.Cell>\n\t\t</Table.Row>\n\t}\n}\n","import {Status} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport {Actor, Actors} from 'parser/core/modules/Actors'\nimport {Data} from 'parser/core/modules/Data'\nimport {Invulnerability} from 'parser/core/modules/Invulnerability'\nimport {Statuses} from 'parser/core/modules/Statuses'\n\nconst MILLISECONDS_PER_MINUTE = 60000\n\ntype DotTracking = Map<Status['id'], Map<Actor['id'], DotTargetTracking>>\ninterface DotTargetTracking {\n\tlastApplied: number\n\ttotalClipping: number\n}\n\nexport abstract class DoTs extends Analyser {\n\tstatic override handle = 'dots'\n\n\t@dependency protected data!: Data\n\t@dependency private actors!: Actors\n\t@dependency private invulnerability!: Invulnerability\n\t@dependency private statuses!: Statuses\n\n\t/** Implementing modules MUST override this with a list of Status IDs. */\n\tprotected abstract trackedStatuses: number[] = []\n\n\tprivate statusApplications: DotTracking = new Map<number, Map<string, DotTargetTracking>>()\n\n\toverride initialise() {\n\t\tthis.addEventHook(\n\t\t\tfilter<Event>()\n\t\t\t\t.type('statusApply')\n\t\t\t\t.source(this.parser.actor.id)\n\t\t\t\t.status(oneOf(this.trackedStatuses)),\n\t\t\tthis.onApply,\n\t\t)\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * Implementing modules MUST override this to configure the checklist.\n\t * This should be handled on a job-by-job basis rather than generically, since the description\n\t * text isn't one-size-fits-all, and some jobs may have custom targets.\n\t */\n\tprotected abstract addChecklistRules(): void\n\n\t/**\n\t * Implementing modules MUST override this to configure suggestions.\n\t * This should be handled on a job-by-job basis rather than generically, since different jobs have\n\t * different thresholds for what constitutes bad clipping with varying explanations as to why.\n\t */\n\tprotected abstract addClippingSuggestions(): void\n\n\t/**\n\t * Implementing modules can optionally exclude applications of a status from clipping calculations.\n\t * (e.g. SMN rushing)\n\t */\n\tprotected excludeApplication() {\n\t\treturn false\n\t}\n\n\tprivate onApply(event: Events['statusApply']) {\n\t\tconst status = this.data.getStatus(event.status)\n\t\t// Cannot track for statuses that are not defined with a duration\n\t\tif (status?.duration == null) { return }\n\n\t\t// Get the tracking object for this status\n\t\tlet trackedStatus = this.statusApplications.get(status.id)\n\t\tif (trackedStatus == null) {\n\t\t\ttrackedStatus = new Map<string, DotTargetTracking>()\n\t\t\tthis.statusApplications.set(status.id, trackedStatus)\n\t\t}\n\n\t\t// Get the tracking object for this status on this target\n\t\tconst target = event.target\n\t\tlet trackedStatusOnTarget = trackedStatus.get(target)\n\t\tif (trackedStatusOnTarget == null) {\n\t\t\ttrackedStatusOnTarget = {lastApplied: 0, totalClipping: 0}\n\t\t\ttrackedStatus.set(target, trackedStatusOnTarget)\n\t\t}\n\n\t\t// If it's not been applied yet or should be excluded per job-specific logic (if any), set it and skip out\n\t\tif (trackedStatusOnTarget.lastApplied === 0 || this.excludeApplication()) {\n\t\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t\t\treturn\n\t\t}\n\n\t\t// Base clip calc\n\t\tconst clip = status.duration - (event.timestamp - trackedStatusOnTarget.lastApplied)\n\t\t// Cap clip at 0 - less than that is downtime, which is handled by the checklist requirement\n\t\ttrackedStatusOnTarget.totalClipping += Math.max(0, clip)\n\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t}\n\n\tprivate onComplete() {\n\t\tthis.addChecklistRules()\n\t\tthis.addClippingSuggestions()\n\t}\n\n\t// These two functions are helpers for submodules and should be used but not overridden\n\tprotected getUptimePercent(statusId: number) {\n\t\tconst status = this.data.getStatus(statusId)\n\t\tif (status == null) { return 0 }\n\n\t\tconst statusUptime = this.statuses.getUptime(status, this.actors.foes)\n\t\tconst fightDuration = this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']})\n\t\treturn (statusUptime / fightDuration) * 100\n\t}\n\n\t// This normalises clipping as milliseconds clipped per minute,\n\t// since some level of clipping is expected and we need tiers that work for both long and short fights\n\tprotected getClippingAmount(statusId: number) {\n\t\tconst fightDuration = (this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']}))\n\t\tif (fightDuration <= 0) { return 0 }\n\n\t\tconst statusApplications = this.statusApplications.get(statusId)\n\t\tif (statusApplications == null) { return 0 }\n\n\t\tconst totalClipping = Array.from(statusApplications.values()).reduce((clip, target) => clip + target.totalClipping, 0)\n\t\tconst clipMSPerMin = Math.round(totalClipping / (fightDuration / MILLISECONDS_PER_MINUTE))\n\t\treturn clipMSPerMin\n\t}\n}\n","import {Trans} from '@lingui/react'\nimport ACTIONS from 'data/ACTIONS'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport Checklist, {Requirement, TARGET, TieredRule} from 'parser/core/modules/Checklist'\nimport {Data} from 'parser/core/modules/Data'\nimport {DataSet, PieChartStatistic, Statistics} from 'parser/core/modules/Statistics'\nimport Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'\nimport React from 'react'\n\ninterface SeverityTiers {\n\t[key: number]: number\n}\n\ninterface TrackedOverhealOpts {\n\tbucketId?: number\n\tname: JSX.Element | string,\n\tcolor?: string\n\ttrackedHealIds?: number[],\n\tignore?: boolean\n\tdebugName?: string\n}\n\nconst REGENERATION_ID: number = 1302\n\nconst SUGGESTION_SEVERITY_TIERS: SeverityTiers = {\n\t0: SEVERITY.MINOR,\n\t35: SEVERITY.MEDIUM,\n\t50: SEVERITY.MAJOR,\n}\n\nconst CHECKLIST_SEVERITY_TIERS: SeverityTiers = {\n\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t[100-35]: TARGET.SUCCESS,\n\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t[100-50]: TARGET.WARN,\n}\n\nexport const SuggestedColors: string[] = [\n\t'#157f1f', // dark green\n\t'#12ba45', // light green\n\t'#00b5ad', // dark teal\n\t'#a0eade', // light teal\n\t'#b5cc18', // ~~snot green~~ why are you using this?\n]\n\nexport class TrackedOverheal {\n\tbucketId: number = -1\n\tignore: boolean\n\tname: JSX.Element | string\n\tcolor: string = '#fff'\n\tprotected trackedHealIds: number[]\n\theal: number = 0\n\toverheal: number = 0\n\tinternalDebugName: string | undefined\n\n\tconstructor(opts: TrackedOverhealOpts) {\n\t\tthis.name = opts.name\n\t\tthis.color = opts.color || this.color\n\t\tthis.trackedHealIds = opts.trackedHealIds || []\n\t\tthis.bucketId = opts.bucketId || -1\n\t\tthis.ignore = opts.ignore || false\n\t\tthis.internalDebugName = opts.debugName\n\t}\n\n\t/**\n\t * Get current overheal as a percentage\n\t */\n\tget percent(): number {\n\t\tif (this.heal > 0) { return 100 * (this.overheal / this.heal) }\n\t\treturn 0\n\t}\n\n\t/**\n\t * Get current overheal as an inverted percentage (for checklist)\n\t */\n\tget percentInverted(): number {\n\t\treturn 100 - this.percent\n\t}\n\n\t/**\n\t * Returns true if there's data to output\n\t */\n\tget hasData(): boolean {\n\t\tif (this.heal > 0 || this.overheal > 0) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Gets a printable name for the category\n\t */\n\tget debugName(): string {\n\t\tif (this.internalDebugName != null) {\n\t\t\treturn this.internalDebugName\n\t\t}\n\n\t\tif (typeof this.name === 'string') {\n\t\t\treturn this.name\n\t\t}\n\n\t\t// Trans tags\n\t\tif (this.name.props.defaults != null) {\n\t\t\treturn this.name.props.defaults\n\t\t}\n\n\t\treturn 'Unknown'\n\t}\n\n\t/**\n\t * Returns true if the action id is tracked\n\t * @param guid\n\t */\n\tidIsTracked(guid: number): boolean {\n\t\tif (this.trackedHealIds.includes(guid)) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Pushes a heal event in for tracking\n\t * @param event - The heal event to track\n\t */\n\tpushHeal(event: Events['heal']) {\n\t\tthis.heal += event.targets.reduce((total, target) => total + target.amount, 0)\n\t\tthis.overheal += event.targets.reduce((total, target) => total + target.overheal, 0)\n\t}\n}\n\nexport class Overheal extends Analyser {\n\tstatic override handle: string = 'overheal'\n\tstatic override debug = false\n\n\t@dependency private checklist!: Checklist\n\t@dependency protected data!: Data\n\t@dependency private suggestions!: Suggestions\n\t@dependency private statistics!: Statistics\n\n\t// Overall tracking options\n\n\t/**\n\t * Implementing modules MAY override this to provide a more relevant name for the overhealing requirement\n\t */\n\tprotected overhealName: JSX.Element = <Trans id=\"core.overheal.direct.name\">Direct</Trans>\n\t/**\n\t * Implementing moduels MAY override this to change the color for direct overheals in the pie chart\n\t */\n\tprotected overhealColor: string = SuggestedColors[0]\n\t/**\n\t * Implementing modules MAY override this to provide a list of heal 'categories' to track\n\t */\n\tprotected trackedHealCategories: TrackedOverhealOpts[] = []\n\n\t// Display options\n\n\t/**\n\t * Implementing modules MAY change this to true in order to spit out a spiffy pie chart\n\t * breakdown of all their categories they're tracking\n\t */\n\tprotected displayPieChart: boolean = false\n\n\t/**\n\t * Implementing modules MAY wish set this to true in order to provide a suggestion\n\t */\n\tprotected displaySuggestion: boolean = false\n\t/**\n\t * Implementing modules MAY change this to set the suggestion icon\n\t */\n\tprotected suggestionIcon: string = ACTIONS.SCH_PHYSICK.icon\n\t/**\n\t * Implementing mdoules MAY change this to set the suggestion text\n\t */\n\tprotected suggestionContent: JSX.Element = <Trans id=\"core.overheal.suggestion.content\">Avoid healing your party for more than is needed. Cut back on unnecessary heals and coordinate with your co-healer to plan resources efficiently.</Trans>\n\t/**\n\t * Implementing modules MAY change this to define the severity tiers for the suggestion\n\t */\n\tprotected suggestionSeverity: SeverityTiers = SUGGESTION_SEVERITY_TIERS\n\n\t/**\n\t * Implementing modules MAY wish to set this to false in order to suppress adding this as a\n\t * checklist item\n\t */\n\tprotected displayChecklist: boolean = true\n\t/**\n\t * Implementing modules MAY wish to override this to set custom severity tiers.\n\t * Do remember that the numbers for checklist are inverted for overheal (e.g., warning at\n\t * 35% overheal means you need to set your threshold at 65)\n\t */\n\tprotected checklistSeverity: SeverityTiers = CHECKLIST_SEVERITY_TIERS\n\t/**\n\t * Implementing modules MAY wish to override this to change the name for the checklist title\n\t */\n\tprotected checklistRuleName: JSX.Element = <Trans id=\"core.overheal.rule.name\">Avoid Overheal</Trans>\n\t/**\n\t * Implementing modules MAY wish to change this in order to reflect the overall healing requiement name\n\t */\n\tprotected checklistRequirementName: JSX.Element = <Trans id=\"core.overheal.requirement.all\">Overall (all sources)</Trans>\n\t/**\n\t * Implementing modules MAY change this to true in order to generate multiple requirements for each\n\t * category of tracked heals; leaving it at false will only generate a single requirement against\n\t * the total overheal percent\n\t */\n\tprotected checklistRuleBreakout: boolean = false\n\n\t// direct healing\n\tprotected direct!: TrackedOverheal\n\t// Everything else\n\tprotected trackedOverheals: TrackedOverheal[] = []\n\n\t/**\n\t * Implementing modules MAY override this to provide the 'why' for suggestion content\n\t * @param overhealPercent\n\t */\n\tprotected suggestionWhy(overhealPercent: number): JSX.Element {\n\t\treturn <Trans id=\"core.overheal.suggestion.why\">You had an overheal of { overhealPercent.toFixed(2) }%</Trans>\n\t}\n\n\toverride initialise() {\n\t\tthis.direct = new TrackedOverheal({\n\t\t\tname: this.overhealName,\n\t\t\tcolor: this.overhealColor,\n\t\t})\n\t\tfor (const healCategoryOpts of this.trackedHealCategories) {\n\t\t\tthis.trackedOverheals.push(new TrackedOverheal(healCategoryOpts))\n\t\t}\n\n\t\tthis.addEventHook(filter<Event>().type('heal').source(this.parser.actor.id), this.onHeal)\n\n\t\tconst actorPets = this.parser.pull.actors\n\t\t\t.filter(actor => actor.owner != null && actor.owner.id === this.parser.actor.id)\n\t\t\t.map(pet => pet.id)\n\t\tthis.addEventHook(filter<Event>().type('heal').source(oneOf(actorPets)), this.onPetHeal)\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * This method MAY be overridden to return true or false, indicating if a heal\n\t * should be counted. If true is returned, the heal is counted towards overheal;\n\t * false ignores the heal entirely.\n\t * @param event\n\t */\n\tprotected considerHeal(_event: Events['heal'], _pet: boolean = false): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * This method MAY be overridden to provide an alternative checklist description\n\t * @param overheals - an array of all the categories of overheals you're tracking, starting with direct\n\t */\n\tprotected checklistDescription(_overheals: TrackedOverheal[]): JSX.Element {\n\t\treturn <Trans id=\"core.overheal.rule.description\">Avoid healing your party for more than is needed. Cut back on unnecessary heals and coordinate with your co-healer to plan resources efficiently.</Trans>\n\t}\n\n\t/**\n\t * This method MAY be overriden to force a heal into a specific bucket for whatever reason\n\t * @param _event - the healing event to consider\n\t * @param _petHeal - whether the heal comes from a pet or not; defaults to false\n\t * @returns a number for the bucket to for a heal into. Return -1 to bucket the heal normally\n\t */\n\tprotected overrideHealBucket(_event: Events['heal'], _petHeal: boolean = false): number {\n\t\treturn -1\n\t}\n\n\tprivate isRegeneration(event: Events['heal']): boolean {\n\t\treturn event.cause.type === 'action' && event.cause.action === REGENERATION_ID\n\t}\n\n\tprivate onHeal(event: Events['heal'], petHeal: boolean = false) {\n\t\tif (this.isRegeneration(event) || ! this.considerHeal(event, petHeal)) { return }\n\n\t\tconst guid = event.cause.type === 'action' ? event.cause.action : event.cause.status\n\t\tconst name = event.cause.type === 'action' ? this.data.getAction(guid)?.name : this.data.getStatus(guid)?.name\n\n\t\tconst bucketId = this.overrideHealBucket(event, petHeal)\n\t\tif (bucketId >= 0) {\n\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\tif (trackedHeal.bucketId === bucketId) {\n\t\t\t\t\tthis.debug(`Heal ${name} (${guid}) at ${event.timestamp} MANUALLY shoved into bucket ${trackedHeal.debugName}`)\n\t\t\t\t\ttrackedHeal.pushHeal(event)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn // return here because you might want to set multiple things with an id to match into multiple categories based on some criteria\n\t\t}\n\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\tif (trackedHeal.idIsTracked(guid)) {\n\t\t\t\tthis.debug(`Heal from ${name} (${guid}) at ${event.timestamp} matched into category ${trackedHeal.debugName}`)\n\t\t\t\ttrackedHeal.pushHeal(event)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tthis.debug(`Heal from ${name} (${guid}) at ${event.timestamp} matched into direct healing`)\n\t\tthis.direct.pushHeal(event)\n\t}\n\n\tprivate onPetHeal(event: Events['heal']) {\n\t\tthis.onHeal(event, true)\n\t}\n\n\tprivate percentageOf(category: number, total: number): number {\n\t\treturn (100 * category) / total\n\t}\n\n\tprivate onComplete() {\n\t\tlet healtotal = this.direct.heal\n\t\tlet overhealtotal = this.direct.overheal\n\n\t\tthis.trackedOverheals.forEach(x => {\n\t\t\tif (!x.ignore && x.hasData) {\n\t\t\t\thealtotal += x.heal\n\t\t\t\toverhealtotal += x.overheal\n\t\t\t}\n\t\t})\n\t\tconst overallOverhealPercent: number = 100 * overhealtotal / healtotal\n\n\t\tif (this.displayPieChart) {\n\t\t\tconst directPercentage = this.percentageOf(this.direct.overheal, overhealtotal)\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t\t\tconst data: DataSet<React.ReactNode, 3> = [{\n\t\t\t\tvalue: directPercentage,\n\t\t\t\tcolor: this.direct.color,\n\t\t\t\tcolumns: [\n\t\t\t\t\tthis.direct.name,\n\t\t\t\t\tthis.percentageOf(this.direct.overheal, overhealtotal).toFixed(2) + '%',\n\t\t\t\t\tthis.direct.percent.toFixed(2) + '%',\n\t\t\t\t],\n\t\t\t}]\n\n\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\tif (!trackedHeal.ignore && trackedHeal.hasData) {\n\t\t\t\t\tconst percentage = this.percentageOf(trackedHeal.overheal, overhealtotal)\n\t\t\t\t\tdata.push({\n\t\t\t\t\t\tvalue: percentage,\n\t\t\t\t\t\tcolor: trackedHeal.color,\n\t\t\t\t\t\tcolumns: [\n\t\t\t\t\t\t\ttrackedHeal.name,\n\t\t\t\t\t\t\tpercentage.toFixed(2) + '%',\n\t\t\t\t\t\t\ttrackedHeal.percent.toFixed(2) + '%',\n\t\t\t\t\t\t],\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.statistics.add(new PieChartStatistic({\n\t\t\t\theadings: [\n\t\t\t\t\t'Type of heal',\n\t\t\t\t\t'% of total overheal',\n\t\t\t\t\t'Overheal % per type',\n\t\t\t\t],\n\t\t\t\tdata: data,\n\t\t\t\twidth: 3, // chart's wide, yo\n\t\t\t}))\n\t\t}\n\n\t\tif (this.displayChecklist) {\n\t\t\tconst requirements: InvertedRequirement[] = []\n\t\t\tif (this.checklistRuleBreakout) {\n\t\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\t\tname: this.overhealName,\n\t\t\t\t\tpercent:  this.direct.percentInverted,\n\t\t\t\t\tweight: 0,\n\t\t\t\t}))\n\n\t\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\t\tif (trackedHeal.ignore) { continue }\n\n\t\t\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\t\t\tname: trackedHeal.name,\n\t\t\t\t\t\tpercent: trackedHeal.percentInverted,\n\t\t\t\t\t\tweight: 0,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\tname: this.checklistRequirementName,\n\t\t\t\tpercent: 100 - overallOverhealPercent,\n\t\t\t}))\n\n\t\t\tthis.checklist.add(new TieredRule({\n\t\t\t\tname: this.checklistRuleName,\n\t\t\t\tdescription: this.checklistDescription([this.direct, ...this.trackedOverheals]),\n\t\t\t\ttiers: this.checklistSeverity,\n\t\t\t\trequirements,\n\t\t\t}))\n\t\t}\n\n\t\tif (this.displaySuggestion) {\n\t\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\t\ticon: this.suggestionIcon,\n\t\t\t\ttiers: this.suggestionSeverity,\n\t\t\t\tvalue: overallOverhealPercent,\n\t\t\t\tcontent: this.suggestionContent,\n\t\t\t\twhy: this.suggestionWhy(overallOverhealPercent),\n\t\t\t}))\n\t\t}\n\t}\n}\n\n// From the original comments:\n// yeh, I'm not doing this in core, but I really want to show overheal as overheal, since that's what the community understands\n// So, in keeping with that spirit, I'm not going to export this at all.\nclass InvertedRequirement extends Requirement {\n\tget percentInverted() {\n\t\treturn 100 - this.percent\n\t}\n\n\toverride get content() {\n\t\tif (this._percent !== null || this.value === null) { return `${this.percentInverted.toFixed(2)}%` }\n\t\treturn `${this.value.toFixed(0)}/${this.target.toFixed(0)}` // avoid weird floating point shit\n\t}\n}\n","import {Status, StatusKey} from 'data/STATUSES'\nimport {Events} from 'event'\nimport {ensureArray} from 'utilities'\nimport {Analyser} from '../Analyser'\nimport {dependency} from '../Injectable'\nimport {Actor, StatusEvent} from './Actors'\nimport {Data} from './Data'\nimport {Invulnerability} from './Invulnerability'\n\ninterface Edge {\n\tside: 'apply' | 'remove'\n\ttimestamp: number\n}\n\nexport class Statuses extends Analyser {\n\tstatic override handle = 'statuses'\n\tstatic override debug = false\n\n\t@dependency private readonly data!: Data\n\t@dependency private readonly invulnerability!: Invulnerability\n\n\t/**\n\t * Calculate the total uptime of the specified status across allspecified actors.\n\t * @param statusSpecifier Status to calculate uptime of.\n\t * @param targetSpecifier Target(s) that should be checked for the status.\n\t * @param source Source of statuses to filter by. Defaults to the parsed actor.\n\t */\n\tgetUptime(\n\t\tstatusSpecifier: StatusKey | Status,\n\t\ttargetSpecifier: Actor | Actor[],\n\t\tsource = this.parser.actor\n\t) {\n\t\t// Resolve arguments.\n\t\tconst status = typeof statusSpecifier === 'string'\n\t\t\t? this.data.statuses[statusSpecifier]\n\t\t\t: statusSpecifier\n\n\t\tconst targets = ensureArray(targetSpecifier)\n\n\t\t// Collect all the status history for the specified status/target/source combo.\n\t\tconst edges = targets.flatMap(target => this.edgesForActor(\n\t\t\ttarget,\n\t\t\ttarget.statusHistory.get(status.id)?.get(source.id) ?? []\n\t\t))\n\n\t\t// Edges are mapped from multiple potential targets; interlace by sorting by timestamp.\n\t\tedges.sort((a, b) => a.timestamp - b.timestamp)\n\n\t\t// Sum time when any of the specified targets had the status.\n\t\tconst meta = {uptime: 0, depth: 0, application: 0}\n\t\tfor (const edge of edges) {\n\t\t\tif (edge.side === 'apply') {\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.application = edge.timestamp\n\t\t\t\t}\n\t\t\t\tmeta.depth ++\n\n\t\t\t} else {\n\t\t\t\tmeta.depth --\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.uptime += edge.timestamp - meta.application\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.debug(`Status ${status.name} ${edge.side} at ${this.ft(edge.timestamp)}, depth=${meta.depth}`)\n\t\t}\n\n\t\treturn meta.uptime\n\t}\n\n\tprivate edgesForActor(target: Actor, events: StatusEvent[]) {\n\t\t// We can safely assume status events from an actor will alternate between apply and remove.\n\t\tconst edges: Edge[] = []\n\t\tlet apply: Events['statusApply'] | undefined\n\t\tlet refresh: Events['statusApply'] | undefined\n\n\t\tfor (const event of events) {\n\t\t\t// Track the initial application and refreshes.\n\t\t\tif (event.type === 'statusApply') {\n\t\t\t\tapply ??= event\n\t\t\t\trefresh = event\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (apply == null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Window has been closed, merge any edges in.\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tevent.timestamp\n\t\t\t))\n\t\t\tapply = undefined\n\t\t}\n\n\t\t// If we've got a dangling apply, build edges for it.\n\t\tif (apply != null) {\n\t\t\t// Try to find a reasonable remove time for the status, if it has a duration.  Cap to the end of the fight.\n\t\t\tconst statusDuration = this.data.getStatus(apply.status)?.duration\n\t\t\tconst remove = statusDuration == null\n\t\t\t\t? this.parser.currentEpochTimestamp\n\t\t\t\t: Math.min((refresh ?? apply).timestamp + statusDuration, this.parser.currentEpochTimestamp)\n\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tremove,\n\t\t\t))\n\t\t}\n\n\t\treturn edges\n\t}\n\n\tprivate splitRangeForInvulns(target: Actor, apply: number, remove: number): Edge[] {\n\t\tlet range = {apply, remove}\n\t\tconst finalRanges = [range]\n\n\t\t// Get the invuln windows that occured during this range\n\t\tconst invulns = this.invulnerability.getWindows({\n\t\t\tstart: apply,\n\t\t\tend: remove,\n\t\t\tactorFilter: actor => actor.kind === target.kind,\n\t\t\ttypes: ['invulnerable'],\n\t\t})\n\n\t\tfor (const invuln of invulns) {\n\t\t\t// Invuln clipped start of range.\n\t\t\tif (invuln.start < range.apply && invuln.end >= range.apply) {\n\t\t\t\tthis.debug(`Start clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t\trange.apply = invuln.end\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Invuln clipped end of range.\n\t\t\tif (invuln.start <= range.remove && invuln.end > range.remove) {\n\t\t\t\tthis.debug(`End clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}]`)\n\n\t\t\t\trange.remove = invuln.start\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Everything else should be a range split, sanity check.\n\t\t\tif (invuln.start < range.apply || invuln.end > range.remove) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tthis.debug(`Split [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}], [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t// Split the range into two around the invuln.\n\t\t\tconst previousRange = range\n\t\t\trange = {...range}\n\t\t\tfinalRanges.push(range)\n\n\t\t\tpreviousRange.remove = invuln.start\n\t\t\trange.apply = invuln.end\n\t\t}\n\n\t\t// Map the ranges into edges.\n\t\treturn finalRanges.flatMap(range => [\n\t\t\t{side: 'apply', timestamp: range.apply},\n\t\t\t{side: 'remove', timestamp: range.remove},\n\t\t] as const)\n\t}\n\n\t// Small utility for formatting timestamps, as we do it a _lot_ in debug messages\n\tprivate ft = (timestamp: number) => this.parser.formatEpochTimestamp(timestamp, 1)\n}\n"],"names":["ItemDepth","ActionTimeline","CastTime","Cooldowns","Data","Timeline","resolvedRows","groupRows","action","this","addRow","content","constructor","rows","config","resolvedConfig","resolveConfig","push","addEventHook","onComplete","populatedGroups","row","populateRow","forEach","specifier","cooldowns","groups","group","add","allGroups","has","finalConfig","Array","isArray","ensureArray","existingRow","get","isDefined","firstContent","label","Trans","id","data","actions","name","cooldownHistory","timeline","ContainerRow","order","collapse","set","addCooldownItems","addChargeItems","chargeHistory","history","entry","duration","getCooldownDuration","start","parser","pull","timestamp","end","addItem","SimpleItem","className","item","delta","ActionItem","depth","ACTION","ChargeGainItem","CHARGE_GAIN","endReason","CooldownEndReason","castTime","forAction","Math","max","Analyser","handle","debug","dependency","Content","styles","Icon","BaseItem","DEFENSIVE_ROLE_ACTIONS","Defensives","CooldownDowntime","trackedDefensives","headerContent","JOBS","actor","job","role","key","roleAction","defensive","getUses","length","totalAdditionalUses","acc","usage","getAdditionalUsageData","chargesBeforeNextUse","getUsageCount","Fragment","icon","exclusive","styled","fluid","panels","index","title","getMaxUses","compact","unstackable","celled","tryGetAdditionalUseRow","getUsageRow","formatEpochTimestamp","circular","size","onClick","show","availableTimestamp","currentCharges","charges","chargesAvailableEvent","current","cooldown","nextEntry","historyEntry","useByTimestamp","floor","displayOrder","DISPLAY_ORDER","cooldownDowntime","DoTs","Actors","Invulnerability","Statuses","trackedStatuses","statusApplications","filter","type","source","status","oneOf","onApply","event","getStatus","trackedStatus","target","trackedStatusOnTarget","lastApplied","totalClipping","excludeApplication","clip","addChecklistRules","addClippingSuggestions","statusId","statuses","getUptime","actors","foes","invulnerability","getDuration","types","fightDuration","round","SUGGESTION_SEVERITY_TIERS","SEVERITY","CHECKLIST_SEVERITY_TIERS","TARGET","SuggestedColors","TrackedOverheal","opts","bucketId","ignore","color","trackedHealIds","heal","overheal","internalDebugName","debugName","percent","props","defaults","guid","targets","total","amount","Overheal","Checklist","Suggestions","Statistics","overhealName","overhealColor","trackedHealCategories","displayPieChart","displaySuggestion","suggestionIcon","ACTIONS","suggestionContent","suggestionSeverity","displayChecklist","checklistSeverity","checklistRuleName","checklistRequirementName","checklistRuleBreakout","direct","trackedOverheals","overhealPercent","toFixed","healCategoryOpts","onHeal","actorPets","owner","pet","onPetHeal","_event","_overheals","cause","petHeal","isRegeneration","considerHeal","getAction","overrideHealBucket","trackedHeal","pushHeal","idIsTracked","category","healtotal","overhealtotal","x","hasData","overallOverhealPercent","value","percentageOf","columns","percentage","statistics","PieChartStatistic","headings","width","requirements","InvertedRequirement","percentInverted","weight","checklist","TieredRule","description","checklistDescription","tiers","suggestions","TieredSuggestion","why","suggestionWhy","_percent","Requirement","ft","statusSpecifier","targetSpecifier","edges","edgesForActor","statusHistory","a","b","meta","uptime","application","edge","side","events","apply","refresh","splitRangeForInvulns","undefined","statusDuration","remove","currentEpochTimestamp","min","range","finalRanges","invulns","getWindows","actorFilter","kind","invuln","previousRange"],"sourceRoot":""}